{"ast":null,"code":"import { createStrictSetupError } from '../utils/error';\nimport { cx } from '../xcss-prop';\n/**\n * ## Create Strict API\n *\n * Returns a strict subset of Compiled APIs augmented by a type definition.\n * This API does not change Compileds build time behavior — merely augmenting\n * the returned API types which enforce:\n *\n * - all APIs use object types\n * - property values declared in the type definition must be used (else fallback to defaults)\n * - a strict subset of pseudo states/selectors\n * - unknown properties to be a type violation\n *\n * To set up:\n *\n * 1. Declare the API in a module (either local or in a package), optionally declaring accepted media queries.\n *\n * @example\n * ```tsx\n * // ./foo.ts\n * interface Schema {\n *   color: 'var(--ds-text)',\n *   '&:hover': { color: 'var(--ds-text-hover)' }\n * }\n *\n * const { css, cssMap, XCSSProp, cx } = createStrictAPI<Schema, { media: '(min-width: 30rem)' }>();\n *\n * export { css, cssMap, XCSSProp, cx };\n * ```\n *\n * 2. Configure Compiled to pick up this module:\n *\n * @example\n * ```diff\n * // .compiledcssrc\n * {\n * +  \"importSources\": [\"./foo.ts\"]\n * }\n * ```\n *\n * 3. Use the module in your application code:\n *\n * @example\n * ```tsx\n * import { css } from './foo';\n *\n * const styles = css({ color: 'var(--ds-text)' });\n *\n * <div css={styles} />\n * ```\n */\nexport function createStrictAPI() {\n  return {\n    css() {\n      throw createStrictSetupError();\n    },\n    cssMap() {\n      throw createStrictSetupError();\n    },\n    cx,\n    XCSSProp() {\n      throw createStrictSetupError();\n    }\n  };\n}","map":{"version":3,"names":["createStrictSetupError","cx","createStrictAPI","css","cssMap","XCSSProp"],"sources":["/home/joshpoms/dndtest2/client/node_modules/@compiled/react/src/create-strict-api/index.ts"],"sourcesContent":["import type { StrictCSSProperties, CSSPseudos, CSSProps } from '../types';\nimport { createStrictSetupError } from '../utils/error';\nimport { type CompiledStyles, cx, type Internal$XCSSProp } from '../xcss-prop';\n\nimport type { AllowedStyles, ApplySchema, ApplySchemaMap, CompiledSchemaShape } from './types';\n\nexport interface StrictOptions {\n  media: string;\n}\n\nexport interface CompiledAPI<\n  TSchema extends CompiledSchemaShape,\n  TAllowedMediaQueries extends string\n> {\n  /**\n   * ## CSS\n   *\n   * Creates styles that are statically typed and useable with other Compiled APIs.\n   * For further details [read the documentation](https://compiledcssinjs.com/docs/api-css).\n   *\n   * This API does not currently work with XCSS prop.\n   *\n   * @example\n   * ```\n   * const redText = css({\n   *   color: 'red',\n   * });\n   *\n   * <div css={redText} />\n   * ```\n   */\n  css<TStyles extends ApplySchema<TStyles, TSchema>>(\n    styles: AllowedStyles<TAllowedMediaQueries> & TStyles\n    // NOTE: This return type is deliberately not using ReadOnly<CompiledStyles<TStyles>>\n    // So it type errors when used with XCSS prop. When we update the compiler to work with\n    // it we can update the return type so it stops being a type violation.\n  ): CSSProps<unknown>;\n  /**\n   * ## CSS Map\n   *\n   * Creates a collection of named styles that are statically typed and useable with other Compiled APIs.\n   * For further details [read the documentation](https://compiledcssinjs.com/docs/api-cssmap).\n   *\n   * @example\n   * ```\n   * const styles = cssMap({\n   *  none: { borderStyle: 'none' },\n   *  solid: { borderStyle: 'solid' },\n   * });\n   *\n   * <div css={styles.solid} />\n   * ```\n   */\n  cssMap<\n    TObject extends Record<string, AllowedStyles<TAllowedMediaQueries>>,\n    TStylesMap extends ApplySchemaMap<TObject, TSchema>\n  >(\n    styles: Record<string, AllowedStyles<TAllowedMediaQueries>> & TStylesMap\n  ): {\n    readonly [P in keyof TStylesMap]: CompiledStyles<TStylesMap[P]>;\n  };\n  /**\n   * ## CX\n   *\n   * Use in conjunction with the {@link XCSSProp} to concatenate and conditionally apply\n   * declared styles. Can only be used with the {@link cssMap} and {@link XCSSProp} APIs.\n   *\n   * @example\n   * ```\n   * const styles = cssMap({\n   *  text: { color: 'var(--ds-text)' },\n   *  primary: { color: 'var(--ds-text-brand)' },\n   * });\n   *\n   * <Component xcss={cx(isPrimary && styles.text, !isPrimary && styles.primary)} />\n   * ```\n   */\n  cx: typeof cx;\n  /**\n   * ## XCSSProp\n   *\n   * Declare styles your component takes with all other styles marked as violations\n   * by the TypeScript compiler. There are two primary use cases for xcss prop:\n   *\n   * - safe style overrides\n   * - inverting style declarations\n   *\n   * Interverting style declarations is interesting for platform teams as\n   * it means products only pay for styles they use as they're now the ones who declare\n   * the styles!\n   *\n   * The {@link XCSSProp} type has generics two of which must be defined — use to explicitly\n   * set want you to maintain as API. Use {@link XCSSAllProperties} and {@link XCSSAllPseudos}\n   * to enable all properties and pseudos.\n   *\n   * The third generic is used to declare what properties and pseudos should be required.\n   *\n   * ```tsx\n   * interface MyComponentProps {\n   *   // Color is accepted, all other properties / pseudos are considered violations.\n   *   xcss?: ReturnType<typeof XCSSProp<'color', never>>;\n   *\n   *   // Only backgrond color and hover pseudo is accepted.\n   *   xcss?: ReturnType<typeof XCSSProp<'backgroundColor', '&:hover'>>;\n   *\n   *   // All properties are accepted, all pseudos are considered violations.\n   *   xcss?: ReturnType<typeof XCSSProp<XCSSAllProperties, never>>;\n   *\n   *   // All properties are accepted, only the hover pseudo is accepted.\n   *   xcss?: ReturnType<typeof XCSSProp<XCSSAllProperties, '&:hover'>>;\n   *\n   *   // The xcss prop is required as well as the color property. No pseudos are required.\n   *   xcss: ReturnType<\n   *    typeof XCSSProp<\n   *      XCSSAllProperties,\n   *      '&:hover',\n   *      { requiredProperties: 'color' }\n   *     >\n   *   >;\n   * }\n   *\n   * function MyComponent({ xcss }: MyComponentProps) {\n   *   return <div css={{ color: 'var(--ds-text-danger)' }} className={xcss} />\n   * }\n   * ```\n   *\n   * The xcss prop works with static inline objects and the [cssMap](https://compiledcssinjs.com/docs/api-cssmap) API.\n   *\n   * ```jsx\n   * // Declared as an inline object\n   * <Component xcss={{ color: 'var(--ds-text)' }} />\n   *\n   * // Declared with the cssMap API\n   * const styles = cssMap({ text: { color: 'var(--ds-text)' } });\n   * <Component xcss={styles.text} />\n   * ```\n   *\n   * To concatenate and conditonally apply styles use the {@link cssMap} and {@link cx} functions.\n   */\n  XCSSProp<\n    TAllowedProperties extends keyof StrictCSSProperties,\n    TAllowedPseudos extends CSSPseudos,\n    TRequiredProperties extends {\n      requiredProperties: TAllowedProperties;\n    } = never\n  >(): Internal$XCSSProp<\n    TAllowedProperties,\n    TAllowedPseudos,\n    TAllowedMediaQueries,\n    TSchema,\n    TRequiredProperties,\n    'strict'\n  >;\n}\n\n/**\n * ## Create Strict API\n *\n * Returns a strict subset of Compiled APIs augmented by a type definition.\n * This API does not change Compileds build time behavior — merely augmenting\n * the returned API types which enforce:\n *\n * - all APIs use object types\n * - property values declared in the type definition must be used (else fallback to defaults)\n * - a strict subset of pseudo states/selectors\n * - unknown properties to be a type violation\n *\n * To set up:\n *\n * 1. Declare the API in a module (either local or in a package), optionally declaring accepted media queries.\n *\n * @example\n * ```tsx\n * // ./foo.ts\n * interface Schema {\n *   color: 'var(--ds-text)',\n *   '&:hover': { color: 'var(--ds-text-hover)' }\n * }\n *\n * const { css, cssMap, XCSSProp, cx } = createStrictAPI<Schema, { media: '(min-width: 30rem)' }>();\n *\n * export { css, cssMap, XCSSProp, cx };\n * ```\n *\n * 2. Configure Compiled to pick up this module:\n *\n * @example\n * ```diff\n * // .compiledcssrc\n * {\n * +  \"importSources\": [\"./foo.ts\"]\n * }\n * ```\n *\n * 3. Use the module in your application code:\n *\n * @example\n * ```tsx\n * import { css } from './foo';\n *\n * const styles = css({ color: 'var(--ds-text)' });\n *\n * <div css={styles} />\n * ```\n */\nexport function createStrictAPI<\n  TSchema extends CompiledSchemaShape,\n  TCreateStrictAPIOptions extends StrictOptions = never\n>(): CompiledAPI<TSchema, TCreateStrictAPIOptions['media']> {\n  return {\n    css() {\n      throw createStrictSetupError();\n    },\n    cssMap() {\n      throw createStrictSetupError();\n    },\n    cx,\n    XCSSProp() {\n      throw createStrictSetupError();\n    },\n  };\n}\n"],"mappings":"AACA,SAASA,sBAAsB,QAAQ,gBAAgB;AACvD,SAA8BC,EAAE,QAAgC,cAAc;AAyJ9E;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA,OAAM,SAAUC,eAAeA,CAAA;EAI7B,OAAO;IACLC,GAAGA,CAAA;MACD,MAAMH,sBAAsB,EAAE;IAChC,CAAC;IACDI,MAAMA,CAAA;MACJ,MAAMJ,sBAAsB,EAAE;IAChC,CAAC;IACDC,EAAE;IACFI,QAAQA,CAAA;MACN,MAAML,sBAAsB,EAAE;IAChC;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}