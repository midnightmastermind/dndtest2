{"ast":null,"code":"// state/masterReducer.js\n// =========================================\n// masterReducer.js — UPDATED to match new ActionTypes\n// Aligned with:\n// - state/actions.js (single ActionTypes object)\n// - bindSocketToStore.js (once you swap dispatch types)\n// - server.js events\n//\n// Notes:\n// - FULL_STATE stays the same.\n// - Removed legacy HYDRATE + PATCH_* + ADD_* cases.\n// - Added CREATE/UPDATE/DELETE for grid/panel/container/instance.\n// - Kept list-based container/items + instances store behavior.\n// =========================================\n\nimport { ActionTypes } from \"./actions\";\nexport function masterReducer(state, action) {\n  var _action$payload21, _action$payload22, _action$payload23;\n  switch (action.type) {\n    // ======================================================\n    // FULL STATE HYDRATE\n    // ======================================================\n    case ActionTypes.FULL_STATE:\n      {\n        const {\n          gridId = null,\n          grid = null,\n          panels = [],\n          grids: availableGrids = [],\n          // server sends these (user-scoped)\n          containers = [],\n          instances = []\n        } = action.payload || {};\n        return {\n          ...state,\n          gridId: gridId !== null && gridId !== void 0 ? gridId : state.gridId,\n          grid,\n          panels: panels || [],\n          availableGrids: availableGrids || [],\n          containers: containers || [],\n          instances: instances || [],\n          hydrated: true\n        };\n      }\n\n    // ======================================================\n    // AUTH / SELECTION\n    // ======================================================\n    case ActionTypes.SET_GRID_ID:\n      {\n        var _action$payload;\n        // bindSocketToStore currently passes payload: payload.gridId (string)\n        // actions.js creator passes { gridId }\n        const gridId = typeof action.payload === \"string\" ? action.payload : (_action$payload = action.payload) === null || _action$payload === void 0 ? void 0 : _action$payload.gridId;\n        return {\n          ...state,\n          gridId: gridId !== null && gridId !== void 0 ? gridId : state.gridId\n        };\n      }\n    case ActionTypes.SET_USER_ID:\n      {\n        var _action$payload2;\n        // allow either shape\n        const userId = typeof action.payload === \"string\" ? action.payload : (_action$payload2 = action.payload) === null || _action$payload2 === void 0 ? void 0 : _action$payload2.userId;\n        return {\n          ...state,\n          userId: userId !== null && userId !== void 0 ? userId : state.userId\n        };\n      }\n    case ActionTypes.LOGOUT:\n      {\n        return {\n          ...state,\n          userId: null,\n          gridId: null,\n          grid: null,\n          panels: [],\n          availableGrids: [],\n          containers: [],\n          instances: [],\n          hydrated: false\n        };\n      }\n    // ======================================================\n    // GRIDS\n    // ======================================================\n    case ActionTypes.SET_AVAILABLE_GRIDS:\n      {\n        var _ref, _action$payload$avail, _action$payload3, _action$payload4;\n        const availableGrids = (_ref = (_action$payload$avail = (_action$payload3 = action.payload) === null || _action$payload3 === void 0 ? void 0 : _action$payload3.availableGrids) !== null && _action$payload$avail !== void 0 ? _action$payload$avail : (_action$payload4 = action.payload) === null || _action$payload4 === void 0 ? void 0 : _action$payload4.grids) !== null && _ref !== void 0 ? _ref : [];\n        return {\n          ...state,\n          availableGrids\n        };\n      }\n    case ActionTypes.SET_GRID:\n      {\n        var _action$payload$grid, _action$payload5;\n        const grid = (_action$payload$grid = (_action$payload5 = action.payload) === null || _action$payload5 === void 0 ? void 0 : _action$payload5.grid) !== null && _action$payload$grid !== void 0 ? _action$payload$grid : null;\n        return {\n          ...state,\n          grid\n        };\n      }\n    case ActionTypes.CREATE_GRID:\n      {\n        var _action$payload6, _grid$_id, _grid$_id$toString;\n        const grid = (_action$payload6 = action.payload) === null || _action$payload6 === void 0 ? void 0 : _action$payload6.grid;\n        if (!grid) return state;\n\n        // if it includes an id, optionally set it\n        const nextGridId = ((_grid$_id = grid._id) === null || _grid$_id === void 0 ? void 0 : (_grid$_id$toString = _grid$_id.toString) === null || _grid$_id$toString === void 0 ? void 0 : _grid$_id$toString.call(_grid$_id)) || grid.id || state.gridId;\n\n        // ensure available grids list includes it if you track that here\n        // (server currently provides grids list on FULL_STATE, so this is optional)\n        return {\n          ...state,\n          gridId: nextGridId,\n          grid\n        };\n      }\n    case ActionTypes.UPDATE_GRID:\n      {\n        var _ref2, _ref3, _action$payload$grid2, _action$payload7, _action$payload8;\n        // bindSocketToStore *should* dispatch payload: { grid: gridPatch }\n        // but we accept both {grid} and {gridPatch} to be safe.\n        const patch = (_ref2 = (_ref3 = (_action$payload$grid2 = (_action$payload7 = action.payload) === null || _action$payload7 === void 0 ? void 0 : _action$payload7.grid) !== null && _action$payload$grid2 !== void 0 ? _action$payload$grid2 : (_action$payload8 = action.payload) === null || _action$payload8 === void 0 ? void 0 : _action$payload8.gridPatch) !== null && _ref3 !== void 0 ? _ref3 : action.payload) !== null && _ref2 !== void 0 ? _ref2 : null;\n        if (!patch) return state;\n        return {\n          ...state,\n          grid: {\n            ...(state.grid || {}),\n            ...(patch || {})\n          }\n        };\n      }\n    case ActionTypes.DELETE_GRID:\n      {\n        var _action$payload$gridI, _action$payload9;\n        // minimal: if deleting current grid, clear\n        const gridId = (_action$payload$gridI = (_action$payload9 = action.payload) === null || _action$payload9 === void 0 ? void 0 : _action$payload9.gridId) !== null && _action$payload$gridI !== void 0 ? _action$payload$gridI : action.payload;\n        if (!gridId) return state;\n        if (state.gridId !== gridId) return state;\n        return {\n          ...state,\n          gridId: null,\n          grid: null,\n          panels: []\n          // containers/instances are user-scoped in your server,\n          // so we DO NOT wipe them on grid delete unless you change that model.\n        };\n      }\n\n    // ======================================================\n    // PANELS\n    // ======================================================\n    case ActionTypes.SET_PANELS:\n      {\n        var _action$payload$panel, _action$payload0;\n        const panels = (_action$payload$panel = (_action$payload0 = action.payload) === null || _action$payload0 === void 0 ? void 0 : _action$payload0.panels) !== null && _action$payload$panel !== void 0 ? _action$payload$panel : [];\n        return {\n          ...state,\n          panels\n        };\n      }\n    case ActionTypes.CREATE_PANEL:\n    case ActionTypes.UPDATE_PANEL:\n      {\n        var _action$payload$panel2, _action$payload1;\n        // bindSocketToStore should dispatch payload: { panel }\n        const panel = (_action$payload$panel2 = (_action$payload1 = action.payload) === null || _action$payload1 === void 0 ? void 0 : _action$payload1.panel) !== null && _action$payload$panel2 !== void 0 ? _action$payload$panel2 : action.payload;\n        if (!(panel !== null && panel !== void 0 && panel.id)) return state;\n        const exists = (state.panels || []).some(p => p.id === panel.id);\n        return {\n          ...state,\n          panels: exists ? state.panels.map(p => p.id === panel.id ? panel : p) : [...(state.panels || []), panel]\n        };\n      }\n    case ActionTypes.DELETE_PANEL:\n      {\n        var _action$payload$panel3, _action$payload10;\n        const panelId = (_action$payload$panel3 = (_action$payload10 = action.payload) === null || _action$payload10 === void 0 ? void 0 : _action$payload10.panelId) !== null && _action$payload$panel3 !== void 0 ? _action$payload$panel3 : action.payload;\n        if (!panelId) return state;\n        return {\n          ...state,\n          panels: (state.panels || []).filter(p => p.id !== panelId)\n        };\n      }\n\n    // ======================================================\n    // CONTAINERS\n    // ======================================================\n    case ActionTypes.SET_CONTAINERS:\n      {\n        var _action$payload$conta, _action$payload11;\n        const containers = (_action$payload$conta = (_action$payload11 = action.payload) === null || _action$payload11 === void 0 ? void 0 : _action$payload11.containers) !== null && _action$payload$conta !== void 0 ? _action$payload$conta : [];\n        return {\n          ...state,\n          containers\n        };\n      }\n    case ActionTypes.CREATE_CONTAINER:\n      {\n        var _action$payload$conta2, _action$payload12, _container$label;\n        // bindSocketToStore should dispatch payload: { container }\n        const container = (_action$payload$conta2 = (_action$payload12 = action.payload) === null || _action$payload12 === void 0 ? void 0 : _action$payload12.container) !== null && _action$payload$conta2 !== void 0 ? _action$payload$conta2 : action.payload;\n        const id = container === null || container === void 0 ? void 0 : container.id;\n        if (!id) return state;\n        const exists = (state.containers || []).some(c => c.id === id);\n        if (exists) return state;\n        return {\n          ...state,\n          containers: [...(state.containers || []), {\n            id,\n            label: (_container$label = container.label) !== null && _container$label !== void 0 ? _container$label : \"Untitled\",\n            items: Array.isArray(container.items) ? container.items : []\n          }]\n        };\n      }\n    case ActionTypes.UPDATE_CONTAINER:\n      {\n        var _action$payload$conta3, _action$payload13;\n        // generic container update (label/items/etc)\n        const container = (_action$payload$conta3 = (_action$payload13 = action.payload) === null || _action$payload13 === void 0 ? void 0 : _action$payload13.container) !== null && _action$payload$conta3 !== void 0 ? _action$payload$conta3 : action.payload;\n        if (!(container !== null && container !== void 0 && container.id)) return state;\n        return {\n          ...state,\n          containers: (state.containers || []).map(c => c.id === container.id ? {\n            ...c,\n            ...container\n          } : c)\n        };\n      }\n    case ActionTypes.UPDATE_CONTAINER_ITEMS:\n      {\n        var _action$payload14, _action$payload15;\n        // bindSocketToStore dispatches { containerId, items }\n        const containerId = (_action$payload14 = action.payload) === null || _action$payload14 === void 0 ? void 0 : _action$payload14.containerId;\n        const items = (_action$payload15 = action.payload) === null || _action$payload15 === void 0 ? void 0 : _action$payload15.items;\n        if (!containerId || !Array.isArray(items)) return state;\n        return {\n          ...state,\n          containers: (state.containers || []).map(c => c.id === containerId ? {\n            ...c,\n            items: [...items]\n          } : c)\n        };\n      }\n    case ActionTypes.DELETE_CONTAINER:\n      {\n        var _action$payload$conta4, _action$payload16;\n        const containerId = (_action$payload$conta4 = (_action$payload16 = action.payload) === null || _action$payload16 === void 0 ? void 0 : _action$payload16.containerId) !== null && _action$payload$conta4 !== void 0 ? _action$payload$conta4 : action.payload;\n        if (!containerId) return state;\n        return {\n          ...state,\n          containers: (state.containers || []).filter(c => c.id !== containerId)\n        };\n      }\n\n    // ======================================================\n    // INSTANCES\n    // ======================================================\n    case ActionTypes.SET_INSTANCES:\n      {\n        var _action$payload$insta, _action$payload17;\n        const instances = (_action$payload$insta = (_action$payload17 = action.payload) === null || _action$payload17 === void 0 ? void 0 : _action$payload17.instances) !== null && _action$payload$insta !== void 0 ? _action$payload$insta : [];\n        return {\n          ...state,\n          instances\n        };\n      }\n    case ActionTypes.CREATE_INSTANCE_IN_CONTAINER:\n      {\n        // payload: { containerId, instance }\n        const {\n          containerId,\n          instance\n        } = action.payload || {};\n        if (!containerId || !(instance !== null && instance !== void 0 && instance.id)) return state;\n        const instanceExists = (state.instances || []).some(i => i.id === instance.id);\n        const nextInstances = instanceExists ? state.instances : [...(state.instances || []), instance];\n        return {\n          ...state,\n          instances: nextInstances,\n          containers: (state.containers || []).map(c => {\n            if (c.id !== containerId) return c;\n            if ((c.items || []).includes(instance.id)) return c;\n            return {\n              ...c,\n              items: [...(c.items || []), instance.id]\n            };\n          })\n        };\n      }\n    case ActionTypes.CREATE_INSTANCE:\n      {\n        var _action$payload$insta2, _action$payload18;\n        // generic create instance (not tied to container)\n        const instance = (_action$payload$insta2 = (_action$payload18 = action.payload) === null || _action$payload18 === void 0 ? void 0 : _action$payload18.instance) !== null && _action$payload$insta2 !== void 0 ? _action$payload$insta2 : action.payload;\n        if (!(instance !== null && instance !== void 0 && instance.id)) return state;\n        const exists = (state.instances || []).some(i => i.id === instance.id);\n        if (exists) return state;\n        return {\n          ...state,\n          instances: [...(state.instances || []), instance]\n        };\n      }\n    case ActionTypes.UPDATE_INSTANCE:\n      {\n        var _action$payload$insta3, _action$payload19;\n        // bindSocketToStore dispatches payload: { instance }\n        const instance = (_action$payload$insta3 = (_action$payload19 = action.payload) === null || _action$payload19 === void 0 ? void 0 : _action$payload19.instance) !== null && _action$payload$insta3 !== void 0 ? _action$payload$insta3 : action.payload;\n        if (!(instance !== null && instance !== void 0 && instance.id)) return state;\n        const exists = (state.instances || []).some(i => i.id === instance.id);\n        return {\n          ...state,\n          instances: exists ? state.instances.map(i => i.id === instance.id ? {\n            ...i,\n            ...instance\n          } : i) : [...(state.instances || []), instance]\n        };\n      }\n    case ActionTypes.DELETE_INSTANCE:\n      {\n        var _action$payload$insta4, _action$payload20;\n        const instanceId = (_action$payload$insta4 = (_action$payload20 = action.payload) === null || _action$payload20 === void 0 ? void 0 : _action$payload20.instanceId) !== null && _action$payload$insta4 !== void 0 ? _action$payload$insta4 : action.payload;\n        if (!instanceId) return state;\n        return {\n          ...state,\n          instances: (state.instances || []).filter(i => i.id !== instanceId),\n          containers: (state.containers || []).map(c => ({\n            ...c,\n            items: (c.items || []).filter(id => id !== instanceId)\n          }))\n        };\n      }\n\n    // ======================================================\n    // DND / UI DEBUG\n    // ======================================================\n    case ActionTypes.SET_ACTIVE_ID:\n      return {\n        ...state,\n        activeId: (_action$payload21 = action.payload) === null || _action$payload21 === void 0 ? void 0 : _action$payload21.activeId\n      };\n    case ActionTypes.SET_ACTIVE_SIZE:\n      return {\n        ...state,\n        activeSize: (_action$payload22 = action.payload) === null || _action$payload22 === void 0 ? void 0 : _action$payload22.activeSize\n      };\n    case ActionTypes.SET_DEBUG_EVENT:\n      return {\n        ...state,\n        debugEvent: (_action$payload23 = action.payload) === null || _action$payload23 === void 0 ? void 0 : _action$payload23.debugEvent\n      };\n    case ActionTypes.SOFT_TICK:\n      return {\n        ...state,\n        softTick: (state.softTick || 0) + 1\n      };\n\n    // ======================================================\n    default:\n      return state;\n  }\n}","map":{"version":3,"names":["ActionTypes","masterReducer","state","action","_action$payload21","_action$payload22","_action$payload23","type","FULL_STATE","gridId","grid","panels","grids","availableGrids","containers","instances","payload","hydrated","SET_GRID_ID","_action$payload","SET_USER_ID","_action$payload2","userId","LOGOUT","SET_AVAILABLE_GRIDS","_ref","_action$payload$avail","_action$payload3","_action$payload4","SET_GRID","_action$payload$grid","_action$payload5","CREATE_GRID","_action$payload6","_grid$_id","_grid$_id$toString","nextGridId","_id","toString","call","id","UPDATE_GRID","_ref2","_ref3","_action$payload$grid2","_action$payload7","_action$payload8","patch","gridPatch","DELETE_GRID","_action$payload$gridI","_action$payload9","SET_PANELS","_action$payload$panel","_action$payload0","CREATE_PANEL","UPDATE_PANEL","_action$payload$panel2","_action$payload1","panel","exists","some","p","map","DELETE_PANEL","_action$payload$panel3","_action$payload10","panelId","filter","SET_CONTAINERS","_action$payload$conta","_action$payload11","CREATE_CONTAINER","_action$payload$conta2","_action$payload12","_container$label","container","c","label","items","Array","isArray","UPDATE_CONTAINER","_action$payload$conta3","_action$payload13","UPDATE_CONTAINER_ITEMS","_action$payload14","_action$payload15","containerId","DELETE_CONTAINER","_action$payload$conta4","_action$payload16","SET_INSTANCES","_action$payload$insta","_action$payload17","CREATE_INSTANCE_IN_CONTAINER","instance","instanceExists","i","nextInstances","includes","CREATE_INSTANCE","_action$payload$insta2","_action$payload18","UPDATE_INSTANCE","_action$payload$insta3","_action$payload19","DELETE_INSTANCE","_action$payload$insta4","_action$payload20","instanceId","SET_ACTIVE_ID","activeId","SET_ACTIVE_SIZE","activeSize","SET_DEBUG_EVENT","debugEvent","SOFT_TICK","softTick"],"sources":["/data/data/com.termux/files/home/dndkittest2/client/src/state/masterReducer.js"],"sourcesContent":["// state/masterReducer.js\n// =========================================\n// masterReducer.js — UPDATED to match new ActionTypes\n// Aligned with:\n// - state/actions.js (single ActionTypes object)\n// - bindSocketToStore.js (once you swap dispatch types)\n// - server.js events\n//\n// Notes:\n// - FULL_STATE stays the same.\n// - Removed legacy HYDRATE + PATCH_* + ADD_* cases.\n// - Added CREATE/UPDATE/DELETE for grid/panel/container/instance.\n// - Kept list-based container/items + instances store behavior.\n// =========================================\n\nimport { ActionTypes } from \"./actions\";\n\nexport function masterReducer(state, action) {\n  switch (action.type) {\n    // ======================================================\n    // FULL STATE HYDRATE\n    // ======================================================\n    case ActionTypes.FULL_STATE: {\n      const {\n        gridId = null,\n        grid = null,\n        panels = [],\n        grids: availableGrids = [],\n\n        // server sends these (user-scoped)\n        containers = [],\n        instances = [],\n      } = action.payload || {};\n\n      return {\n        ...state,\n        gridId: gridId ?? state.gridId,\n        grid,\n        panels: panels || [],\n        availableGrids: availableGrids || [],\n        containers: containers || [],\n        instances: instances || [],\n        hydrated: true,\n      };\n    }\n\n    // ======================================================\n    // AUTH / SELECTION\n    // ======================================================\n    case ActionTypes.SET_GRID_ID: {\n      // bindSocketToStore currently passes payload: payload.gridId (string)\n      // actions.js creator passes { gridId }\n      const gridId = typeof action.payload === \"string\" ? action.payload : action.payload?.gridId;\n      return { ...state, gridId: gridId ?? state.gridId };\n    }\n\n    case ActionTypes.SET_USER_ID: {\n      // allow either shape\n      const userId = typeof action.payload === \"string\" ? action.payload : action.payload?.userId;\n      return { ...state, userId: userId ?? state.userId };\n    }\ncase ActionTypes.LOGOUT: {\n  return {\n    ...state,\n    userId: null,\n    gridId: null,\n    grid: null,\n    panels: [],\n    availableGrids: [],\n    containers: [],\n    instances: [],\n    hydrated: false,\n  };\n}\n    // ======================================================\n    // GRIDS\n    // ======================================================\n    case ActionTypes.SET_AVAILABLE_GRIDS: {\n      const availableGrids =\n        action.payload?.availableGrids ??\n        action.payload?.grids ??\n        [];\n      return { ...state, availableGrids };\n    }\n\n    case ActionTypes.SET_GRID: {\n      const grid = action.payload?.grid ?? null;\n      return { ...state, grid };\n    }\n\n    case ActionTypes.CREATE_GRID: {\n      const grid = action.payload?.grid;\n      if (!grid) return state;\n\n      // if it includes an id, optionally set it\n      const nextGridId = grid._id?.toString?.() || grid.id || state.gridId;\n\n      // ensure available grids list includes it if you track that here\n      // (server currently provides grids list on FULL_STATE, so this is optional)\n      return {\n        ...state,\n        gridId: nextGridId,\n        grid,\n      };\n    }\n\n    case ActionTypes.UPDATE_GRID: {\n      // bindSocketToStore *should* dispatch payload: { grid: gridPatch }\n      // but we accept both {grid} and {gridPatch} to be safe.\n      const patch = action.payload?.grid ?? action.payload?.gridPatch ?? action.payload ?? null;\n      if (!patch) return state;\n\n      return {\n        ...state,\n        grid: { ...(state.grid || {}), ...(patch || {}) },\n      };\n    }\n\n    case ActionTypes.DELETE_GRID: {\n      // minimal: if deleting current grid, clear\n      const gridId = action.payload?.gridId ?? action.payload;\n      if (!gridId) return state;\n\n      if (state.gridId !== gridId) return state;\n\n      return {\n        ...state,\n        gridId: null,\n        grid: null,\n        panels: [],\n        // containers/instances are user-scoped in your server,\n        // so we DO NOT wipe them on grid delete unless you change that model.\n      };\n    }\n\n    // ======================================================\n    // PANELS\n    // ======================================================\n    case ActionTypes.SET_PANELS: {\n      const panels = action.payload?.panels ?? [];\n      return { ...state, panels };\n    }\n\n    case ActionTypes.CREATE_PANEL:\n    case ActionTypes.UPDATE_PANEL: {\n      // bindSocketToStore should dispatch payload: { panel }\n      const panel = action.payload?.panel ?? action.payload;\n      if (!panel?.id) return state;\n\n      const exists = (state.panels || []).some((p) => p.id === panel.id);\n\n      return {\n        ...state,\n        panels: exists\n          ? state.panels.map((p) => (p.id === panel.id ? panel : p))\n          : [...(state.panels || []), panel],\n      };\n    }\n\n    case ActionTypes.DELETE_PANEL: {\n      const panelId = action.payload?.panelId ?? action.payload;\n      if (!panelId) return state;\n\n      return {\n        ...state,\n        panels: (state.panels || []).filter((p) => p.id !== panelId),\n      };\n    }\n\n    // ======================================================\n    // CONTAINERS\n    // ======================================================\n    case ActionTypes.SET_CONTAINERS: {\n      const containers = action.payload?.containers ?? [];\n      return { ...state, containers };\n    }\n\n    case ActionTypes.CREATE_CONTAINER: {\n      // bindSocketToStore should dispatch payload: { container }\n      const container = action.payload?.container ?? action.payload;\n      const id = container?.id;\n      if (!id) return state;\n\n      const exists = (state.containers || []).some((c) => c.id === id);\n      if (exists) return state;\n\n      return {\n        ...state,\n        containers: [\n          ...(state.containers || []),\n          {\n            id,\n            label: container.label ?? \"Untitled\",\n            items: Array.isArray(container.items) ? container.items : [],\n          },\n        ],\n      };\n    }\n\n    case ActionTypes.UPDATE_CONTAINER: {\n      // generic container update (label/items/etc)\n      const container = action.payload?.container ?? action.payload;\n      if (!container?.id) return state;\n\n      return {\n        ...state,\n        containers: (state.containers || []).map((c) =>\n          c.id === container.id ? { ...c, ...container } : c\n        ),\n      };\n    }\n\n    case ActionTypes.UPDATE_CONTAINER_ITEMS: {\n      // bindSocketToStore dispatches { containerId, items }\n      const containerId = action.payload?.containerId;\n      const items = action.payload?.items;\n      if (!containerId || !Array.isArray(items)) return state;\n\n      return {\n        ...state,\n        containers: (state.containers || []).map((c) =>\n          c.id === containerId ? { ...c, items: [...items] } : c\n        ),\n      };\n    }\n\n    case ActionTypes.DELETE_CONTAINER: {\n      const containerId = action.payload?.containerId ?? action.payload;\n      if (!containerId) return state;\n\n      return {\n        ...state,\n        containers: (state.containers || []).filter((c) => c.id !== containerId),\n      };\n    }\n\n    // ======================================================\n    // INSTANCES\n    // ======================================================\n    case ActionTypes.SET_INSTANCES: {\n      const instances = action.payload?.instances ?? [];\n      return { ...state, instances };\n    }\n\n    case ActionTypes.CREATE_INSTANCE_IN_CONTAINER: {\n      // payload: { containerId, instance }\n      const { containerId, instance } = action.payload || {};\n      if (!containerId || !instance?.id) return state;\n\n      const instanceExists = (state.instances || []).some((i) => i.id === instance.id);\n      const nextInstances = instanceExists ? state.instances : [...(state.instances || []), instance];\n\n      return {\n        ...state,\n        instances: nextInstances,\n        containers: (state.containers || []).map((c) => {\n          if (c.id !== containerId) return c;\n          if ((c.items || []).includes(instance.id)) return c;\n          return { ...c, items: [...(c.items || []), instance.id] };\n        }),\n      };\n    }\n\n    case ActionTypes.CREATE_INSTANCE: {\n      // generic create instance (not tied to container)\n      const instance = action.payload?.instance ?? action.payload;\n      if (!instance?.id) return state;\n\n      const exists = (state.instances || []).some((i) => i.id === instance.id);\n      if (exists) return state;\n\n      return { ...state, instances: [...(state.instances || []), instance] };\n    }\n\n    case ActionTypes.UPDATE_INSTANCE: {\n      // bindSocketToStore dispatches payload: { instance }\n      const instance = action.payload?.instance ?? action.payload;\n      if (!instance?.id) return state;\n\n      const exists = (state.instances || []).some((i) => i.id === instance.id);\n\n      return {\n        ...state,\n        instances: exists\n          ? state.instances.map((i) => (i.id === instance.id ? { ...i, ...instance } : i))\n          : [...(state.instances || []), instance],\n      };\n    }\n\n    case ActionTypes.DELETE_INSTANCE: {\n      const instanceId = action.payload?.instanceId ?? action.payload;\n      if (!instanceId) return state;\n\n      return {\n        ...state,\n        instances: (state.instances || []).filter((i) => i.id !== instanceId),\n        containers: (state.containers || []).map((c) => ({\n          ...c,\n          items: (c.items || []).filter((id) => id !== instanceId),\n        })),\n      };\n    }\n\n    // ======================================================\n    // DND / UI DEBUG\n    // ======================================================\n    case ActionTypes.SET_ACTIVE_ID:\n      return { ...state, activeId: action.payload?.activeId };\n\n    case ActionTypes.SET_ACTIVE_SIZE:\n      return { ...state, activeSize: action.payload?.activeSize };\n\n    case ActionTypes.SET_DEBUG_EVENT:\n      return { ...state, debugEvent: action.payload?.debugEvent };\n\n    case ActionTypes.SOFT_TICK:\n      return { ...state, softTick: (state.softTick || 0) + 1 };\n\n    // ======================================================\n    default:\n      return state;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}