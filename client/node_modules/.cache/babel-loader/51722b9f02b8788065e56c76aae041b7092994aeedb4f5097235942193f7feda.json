{"ast":null,"code":"// state/masterReducer.js\nimport { ActionTypes } from \"./actions\";\nexport function masterReducer(state, action) {\n  switch (action.type) {\n    // ------------------------------\n    // FULL STATE (old server style)\n    // ------------------------------\n    case ActionTypes.FULL_STATE:\n      {\n        const {\n          gridId = null,\n          grid = null,\n          panels = [],\n          grids: availableGrids = [],\n          // your new server may still send these:\n          containers = [],\n          instances = []\n        } = action.payload || {};\n        return {\n          ...state,\n          gridId: gridId !== null && gridId !== void 0 ? gridId : state.gridId,\n          grid,\n          panels: panels || [],\n          availableGrids: availableGrids || [],\n          containers: containers || [],\n          instances: instances || [],\n          hydrated: true\n        };\n      }\n    case ActionTypes.HYDRATE:\n      {\n        // keep if you still use it anywhere\n        const {\n          gridId,\n          grid,\n          panels,\n          containers,\n          instances\n        } = action.payload || {};\n        return {\n          ...state,\n          gridId,\n          grid,\n          panels: panels || [],\n          containers: containers || [],\n          instances: instances || [],\n          hydrated: true\n        };\n      }\n    case ActionTypes.SET_GRID_ID:\n      return {\n        ...state,\n        gridId: action.payload\n      };\n    case ActionTypes.SET_USER_ID:\n      return {\n        ...state,\n        userId: action.payload\n      };\n    case ActionTypes.PATCH_GRID:\n      return {\n        ...state,\n        grid: {\n          ...(state.grid || {}),\n          ...(action.payload.grid || {})\n        }\n      };\n    case ActionTypes.PATCH_PANEL:\n      {\n        const p = action.payload.panel;\n        if (!(p !== null && p !== void 0 && p.id)) return state;\n        const exists = state.panels.some(x => x.id === p.id);\n        return {\n          ...state,\n          panels: exists ? state.panels.map(x => x.id === p.id ? p : x) : [...state.panels, p]\n        };\n      }\n\n    // ------------------------------\n    // your new list-based logic\n    // ------------------------------\n    case ActionTypes.ADD_CONTAINER:\n      {\n        const {\n          id,\n          label\n        } = action.payload;\n        if (!id) return state;\n        if (state.containers.some(c => c.id === id)) return state;\n        return {\n          ...state,\n          containers: [...state.containers, {\n            id,\n            label,\n            items: []\n          }]\n        };\n      }\n    case ActionTypes.ADD_INSTANCE_TO_CONTAINER:\n      {\n        const {\n          containerId,\n          instance\n        } = action.payload;\n        if (!containerId || !(instance !== null && instance !== void 0 && instance.id)) return state;\n        const instanceExists = state.instances.some(i => i.id === instance.id);\n        const nextInstances = instanceExists ? state.instances : [...state.instances, instance];\n        return {\n          ...state,\n          instances: nextInstances,\n          containers: state.containers.map(c => {\n            if (c.id !== containerId) return c;\n            if (c.items.includes(instance.id)) return c;\n            return {\n              ...c,\n              items: [...c.items, instance.id]\n            };\n          })\n        };\n      }\n    case ActionTypes.SET_ACTIVE_ID:\n      return {\n        ...state,\n        activeId: action.payload.activeId\n      };\n    case ActionTypes.SET_ACTIVE_SIZE:\n      return {\n        ...state,\n        activeSize: action.payload.activeSize\n      };\n    case ActionTypes.SET_DEBUG_EVENT:\n      return {\n        ...state,\n        debugEvent: action.payload.debugEvent\n      };\n    case ActionTypes.SET_CONTAINERS:\n      return {\n        ...state,\n        containers: action.payload.containers\n      };\n    case ActionTypes.SET_INSTANCES:\n      return {\n        ...state,\n        instances: action.payload.instances\n      };\n    case ActionTypes.PATCH_CONTAINER_ITEMS:\n      {\n        const {\n          containerId,\n          items\n        } = action.payload;\n        return {\n          ...state,\n          containers: state.containers.map(c => c.id === containerId ? {\n            ...c,\n            items\n          } : c)\n        };\n      }\n    case ActionTypes.PATCH_INSTANCE:\n      {\n        const {\n          instance\n        } = action.payload;\n        return {\n          ...state,\n          instances: state.instances.map(i => i.id === instance.id ? instance : i)\n        };\n      }\n    case ActionTypes.SOFT_TICK:\n      return {\n        ...state,\n        softTick: state.softTick + 1\n      };\n    default:\n      return state;\n  }\n}","map":{"version":3,"names":["ActionTypes","masterReducer","state","action","type","FULL_STATE","gridId","grid","panels","grids","availableGrids","containers","instances","payload","hydrated","HYDRATE","SET_GRID_ID","SET_USER_ID","userId","PATCH_GRID","PATCH_PANEL","p","panel","id","exists","some","x","map","ADD_CONTAINER","label","c","items","ADD_INSTANCE_TO_CONTAINER","containerId","instance","instanceExists","i","nextInstances","includes","SET_ACTIVE_ID","activeId","SET_ACTIVE_SIZE","activeSize","SET_DEBUG_EVENT","debugEvent","SET_CONTAINERS","SET_INSTANCES","PATCH_CONTAINER_ITEMS","PATCH_INSTANCE","SOFT_TICK","softTick"],"sources":["/home/joshpoms/dndtest2/client/src/state/masterReducer.js"],"sourcesContent":["// state/masterReducer.js\nimport { ActionTypes } from \"./actions\";\n\nexport function masterReducer(state, action) {\n  switch (action.type) {\n    // ------------------------------\n    // FULL STATE (old server style)\n    // ------------------------------\n    case ActionTypes.FULL_STATE: {\n      const {\n        gridId = null,\n        grid = null,\n        panels = [],\n        grids: availableGrids = [],\n\n        // your new server may still send these:\n        containers = [],\n        instances = [],\n      } = action.payload || {};\n\n      return {\n        ...state,\n        gridId: gridId ?? state.gridId,\n        grid,\n        panels: panels || [],\n        availableGrids: availableGrids || [],\n        containers: containers || [],\n        instances: instances || [],\n        hydrated: true,\n      };\n    }\n\n    case ActionTypes.HYDRATE: {\n      // keep if you still use it anywhere\n      const { gridId, grid, panels, containers, instances } = action.payload || {};\n      return {\n        ...state,\n        gridId,\n        grid,\n        panels: panels || [],\n        containers: containers || [],\n        instances: instances || [],\n        hydrated: true,\n      };\n    }\n\n    case ActionTypes.SET_GRID_ID:\n      return { ...state, gridId: action.payload };\n\n    case ActionTypes.SET_USER_ID:\n      return { ...state, userId: action.payload };\n\n    case ActionTypes.PATCH_GRID:\n      return { ...state, grid: { ...(state.grid || {}), ...(action.payload.grid || {}) } };\n\n    case ActionTypes.PATCH_PANEL: {\n      const p = action.payload.panel;\n      if (!p?.id) return state;\n      const exists = state.panels.some((x) => x.id === p.id);\n      return {\n        ...state,\n        panels: exists ? state.panels.map((x) => (x.id === p.id ? p : x)) : [...state.panels, p],\n      };\n    }\n\n    // ------------------------------\n    // your new list-based logic\n    // ------------------------------\n    case ActionTypes.ADD_CONTAINER: {\n      const { id, label } = action.payload;\n      if (!id) return state;\n      if (state.containers.some((c) => c.id === id)) return state;\n      return { ...state, containers: [...state.containers, { id, label, items: [] }] };\n    }\n\n    case ActionTypes.ADD_INSTANCE_TO_CONTAINER: {\n      const { containerId, instance } = action.payload;\n      if (!containerId || !instance?.id) return state;\n\n      const instanceExists = state.instances.some((i) => i.id === instance.id);\n      const nextInstances = instanceExists ? state.instances : [...state.instances, instance];\n\n      return {\n        ...state,\n        instances: nextInstances,\n        containers: state.containers.map((c) => {\n          if (c.id !== containerId) return c;\n          if (c.items.includes(instance.id)) return c;\n          return { ...c, items: [...c.items, instance.id] };\n        }),\n      };\n    }\n\n    case ActionTypes.SET_ACTIVE_ID:\n      return { ...state, activeId: action.payload.activeId };\n\n    case ActionTypes.SET_ACTIVE_SIZE:\n      return { ...state, activeSize: action.payload.activeSize };\n\n    case ActionTypes.SET_DEBUG_EVENT:\n      return { ...state, debugEvent: action.payload.debugEvent };\n\n    case ActionTypes.SET_CONTAINERS:\n      return { ...state, containers: action.payload.containers };\n\n    case ActionTypes.SET_INSTANCES:\n      return { ...state, instances: action.payload.instances };\n\n    case ActionTypes.PATCH_CONTAINER_ITEMS: {\n      const { containerId, items } = action.payload;\n      return {\n        ...state,\n        containers: state.containers.map((c) => (c.id === containerId ? { ...c, items } : c)),\n      };\n    }\n\n    case ActionTypes.PATCH_INSTANCE: {\n      const { instance } = action.payload;\n      return {\n        ...state,\n        instances: state.instances.map((i) => (i.id === instance.id ? instance : i)),\n      };\n    }\n\n    case ActionTypes.SOFT_TICK:\n      return { ...state, softTick: state.softTick + 1 };\n\n    default:\n      return state;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}