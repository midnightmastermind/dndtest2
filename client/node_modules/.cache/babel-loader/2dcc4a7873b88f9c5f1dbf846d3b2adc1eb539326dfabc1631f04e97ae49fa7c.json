{"ast":null,"code":"var _s = $RefreshSig$();\n// dnd/useDndReorderCoordinator.js\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { createContainerAction, createInstanceInContainerAction, setActiveIdAction, setActiveSizeAction, setContainersAction, setDebugEventAction, softTickAction,\n// ✅ ADD: panel updates for container sorting\nupdatePanelAction } from \"../state/actions\";\n\n// ---------- utilities ----------\nfunction uid() {\n  return Date.now().toString(36) + Math.random().toString(36).slice(2, 10);\n}\nfunction arrayMove(arr, from, to) {\n  const copy = [...arr];\n  const [item] = copy.splice(from, 1);\n  copy.splice(to, 0, item);\n  return copy;\n}\nfunction deepCloneContainers(containers) {\n  return (containers || []).map(c => ({\n    ...c,\n    items: [...(c.items || [])]\n  }));\n}\n\n// ✅ Safe event snapshot for debug UI (no circular refs)\nfunction pickEvent(event, type) {\n  var _a$data, _o$data, _activeData$role, _activeData$container, _activeData$panelId, _overData$role, _overData$containerId, _overData$panelId;\n  const a = event === null || event === void 0 ? void 0 : event.active;\n  const o = event === null || event === void 0 ? void 0 : event.over;\n  const activeData = (a === null || a === void 0 ? void 0 : (_a$data = a.data) === null || _a$data === void 0 ? void 0 : _a$data.current) || null;\n  const overData = (o === null || o === void 0 ? void 0 : (_o$data = o.data) === null || _o$data === void 0 ? void 0 : _o$data.current) || null;\n  return {\n    type,\n    ts: Date.now(),\n    active: a ? {\n      id: a.id,\n      role: (_activeData$role = activeData === null || activeData === void 0 ? void 0 : activeData.role) !== null && _activeData$role !== void 0 ? _activeData$role : null,\n      containerId: (_activeData$container = activeData === null || activeData === void 0 ? void 0 : activeData.containerId) !== null && _activeData$container !== void 0 ? _activeData$container : null,\n      panelId: (_activeData$panelId = activeData === null || activeData === void 0 ? void 0 : activeData.panelId) !== null && _activeData$panelId !== void 0 ? _activeData$panelId : null,\n      // ✅ helpful for debugging\n      data: activeData\n    } : null,\n    over: o ? {\n      id: o.id,\n      role: (_overData$role = overData === null || overData === void 0 ? void 0 : overData.role) !== null && _overData$role !== void 0 ? _overData$role : null,\n      containerId: (_overData$containerId = overData === null || overData === void 0 ? void 0 : overData.containerId) !== null && _overData$containerId !== void 0 ? _overData$containerId : null,\n      panelId: (_overData$panelId = overData === null || overData === void 0 ? void 0 : overData.panelId) !== null && _overData$panelId !== void 0 ? _overData$panelId : null,\n      // ✅ helpful for debugging\n      data: overData\n    } : null\n  };\n}\nfunction getOverContainerId(over) {\n  var _over$data, _over$data$current;\n  if (!over) return null;\n\n  // preferred: explicit data\n  const cid = (_over$data = over.data) === null || _over$data === void 0 ? void 0 : (_over$data$current = _over$data.current) === null || _over$data$current === void 0 ? void 0 : _over$data$current.containerId;\n  if (cid) return cid;\n\n  // fallback: parse droppable id patterns (list:/top:/bottom:)\n  if (typeof over.id === \"string\") {\n    if (over.id.startsWith(\"list:\")) return over.id.slice(\"list:\".length);\n    if (over.id.startsWith(\"top:\")) return over.id.slice(\"top:\".length);\n    if (over.id.startsWith(\"bottom:\")) return over.id.slice(\"bottom:\".length);\n  }\n  return null;\n}\nfunction findPanelByContainerId(containerId, panels = []) {\n  return (panels || []).find(p => (p.containers || []).includes(containerId));\n}\nfunction findContainerByInstanceId(instanceId, list) {\n  return (list || []).find(c => (c.items || []).includes(instanceId));\n}\nfunction itemsEqual(a = [], b = []) {\n  if (a === b) return true;\n  if (!a || !b) return false;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n  return true;\n}\n\n// ---------- hook ----------\nexport function useDndReorderCoordinator({\n  state,\n  dispatch,\n  socket\n}) {\n  _s();\n  // soft-sort draft ref (kept out of reducer on purpose)\n  const containersDraftRef = useRef(null);\n  const lastOverRef = useRef({\n    activeId: null,\n    overId: null,\n    overRole: null,\n    overContainerId: null\n  });\n\n  // ✅ prevent container sort spam\n  const lastContainerSortRef = useRef({\n    panelId: null,\n    activeContainerId: null,\n    overContainerId: null\n  });\n\n  // ✅ track which panel got reordered, so dragEnd can persist once\n  const containerSortPanelIdRef = useRef(null);\n  const getWorkingContainers = useCallback(() => {\n    var _containersDraftRef$c;\n    return (_containersDraftRef$c = containersDraftRef.current) !== null && _containersDraftRef$c !== void 0 ? _containersDraftRef$c : state.containers;\n  }, [state.containers]);\n  const handleDragStart = useCallback(event => {\n    var _event$active$rect, _event$active$rect$cu;\n    dispatch(setDebugEventAction(pickEvent(event, \"start\")));\n    dispatch(setActiveIdAction(event.active.id));\n    const rect = (_event$active$rect = event.active.rect) === null || _event$active$rect === void 0 ? void 0 : (_event$active$rect$cu = _event$active$rect.current) === null || _event$active$rect$cu === void 0 ? void 0 : _event$active$rect$cu.initial;\n    if (rect) dispatch(setActiveSizeAction({\n      width: rect.width,\n      height: rect.height\n    }));\n\n    // ✅ only needed for instance sorting; harmless to set always\n    containersDraftRef.current = deepCloneContainers(state.containers);\n    lastOverRef.current = {\n      activeId: event.active.id,\n      overId: null,\n      overRole: null,\n      overContainerId: null\n    };\n    lastContainerSortRef.current = {\n      panelId: null,\n      activeContainerId: null,\n      overContainerId: null\n    };\n    containerSortPanelIdRef.current = null;\n    dispatch(softTickAction());\n  }, [dispatch, state.containers]);\n  const handleDragCancel = useCallback(() => {\n    dispatch(setDebugEventAction({\n      type: \"cancel\",\n      ts: Date.now()\n    }));\n    dispatch(setActiveIdAction(null));\n    dispatch(setActiveSizeAction(null));\n    containersDraftRef.current = null;\n    containerSortPanelIdRef.current = null;\n    dispatch(softTickAction());\n  }, [dispatch]);\n  const handleDragOver = useCallback(event => {\n    var _over$data$current$ro, _over$data2, _over$data2$current, _over$data$current$co, _over$data3, _over$data3$current, _active$data$current$, _active$data, _active$data$current;\n    const {\n      active,\n      over\n    } = event;\n    if (!over) return;\n    const nextOverRole = (_over$data$current$ro = (_over$data2 = over.data) === null || _over$data2 === void 0 ? void 0 : (_over$data2$current = _over$data2.current) === null || _over$data2$current === void 0 ? void 0 : _over$data2$current.role) !== null && _over$data$current$ro !== void 0 ? _over$data$current$ro : null;\n    const nextOverContainerId = (_over$data$current$co = (_over$data3 = over.data) === null || _over$data3 === void 0 ? void 0 : (_over$data3$current = _over$data3.current) === null || _over$data3$current === void 0 ? void 0 : _over$data3$current.containerId) !== null && _over$data$current$co !== void 0 ? _over$data$current$co : typeof over.id === \"string\" ? over.id : null;\n    const last = lastOverRef.current;\n    const sameOver = last.activeId === active.id && last.overId === over.id && last.overRole === nextOverRole && last.overContainerId === nextOverContainerId;\n    if (!sameOver) {\n      lastOverRef.current = {\n        activeId: active.id,\n        overId: over.id,\n        overRole: nextOverRole,\n        overContainerId: nextOverContainerId\n      };\n      dispatch(setDebugEventAction(pickEvent(event, \"over\")));\n    }\n    const activeRole = (_active$data$current$ = (_active$data = active.data) === null || _active$data === void 0 ? void 0 : (_active$data$current = _active$data.current) === null || _active$data$current === void 0 ? void 0 : _active$data$current.role) !== null && _active$data$current$ !== void 0 ? _active$data$current$ : null;\n    const overRole = nextOverRole;\n\n    // ======================================================\n    // ✅ CONTAINER SORT (inside a panel)\n    // ======================================================\n    if (activeRole === \"container\") {\n      var _ref, _active$data$current$2, _active$data2, _active$data2$current, _over$data4, _over$data4$current, _findPanelByContainer;\n      // Only when hovering another container tile\n      if (overRole !== \"container\") return;\n      const activeContainerId = active.id;\n      const overContainerId = over.id;\n\n      // Determine panel\n      const panelId = (_ref = (_active$data$current$2 = (_active$data2 = active.data) === null || _active$data2 === void 0 ? void 0 : (_active$data2$current = _active$data2.current) === null || _active$data2$current === void 0 ? void 0 : _active$data2$current.panelId) !== null && _active$data$current$2 !== void 0 ? _active$data$current$2 : (_over$data4 = over.data) === null || _over$data4 === void 0 ? void 0 : (_over$data4$current = _over$data4.current) === null || _over$data4$current === void 0 ? void 0 : _over$data4$current.panelId) !== null && _ref !== void 0 ? _ref : (_findPanelByContainer = findPanelByContainerId(activeContainerId, state.panels || [])) === null || _findPanelByContainer === void 0 ? void 0 : _findPanelByContainer.id;\n      if (!panelId) return;\n      const panel = (state.panels || []).find(p => p.id === panelId);\n      if (!panel) return;\n      const ids = panel.containers || [];\n      const fromIndex = ids.indexOf(activeContainerId);\n      const toIndex = ids.indexOf(overContainerId);\n      if (fromIndex === -1 || toIndex === -1) return;\n      if (fromIndex === toIndex) return;\n\n      // de-dupe\n      const lastC = lastContainerSortRef.current;\n      if (lastC.panelId === panelId && lastC.activeContainerId === activeContainerId && lastC.overContainerId === overContainerId) {\n        return;\n      }\n      lastContainerSortRef.current = {\n        panelId,\n        activeContainerId,\n        overContainerId\n      };\n      const nextIds = arrayMove(ids, fromIndex, toIndex);\n\n      // ✅ update panel order immediately so rectSortingStrategy animates\n      dispatch(updatePanelAction({\n        ...panel,\n        containers: nextIds\n      }));\n      containerSortPanelIdRef.current = panelId;\n      dispatch(softTickAction());\n      return;\n    }\n\n    // ======================================================\n    // INSTANCE SORT (your existing logic)\n    // ======================================================\n    const draft = containersDraftRef.current;\n    if (!draft) return;\n    if (activeRole !== \"instance\") return;\n    const instanceId = active.id;\n    const fromContainer = findContainerByInstanceId(instanceId, draft);\n    if (!fromContainer) return;\n    const toContainerId = getOverContainerId(over);\n    if (!toContainerId) return;\n    const toContainer = draft.find(c => c.id === toContainerId);\n    if (!toContainer) return;\n    const fromId = fromContainer.id;\n    const toId = toContainer.id;\n    const fromIndex = fromContainer.items.indexOf(instanceId);\n    if (fromIndex === -1) return;\n    const isOverInstance = overRole === \"instance\";\n    const overInstanceId = isOverInstance ? over.id : null;\n    let toIndex;\n    if (!overInstanceId) {\n      toIndex = toContainer.items.length;\n    } else {\n      var _active$rect, _active$rect$current;\n      const idx = toContainer.items.indexOf(overInstanceId);\n      toIndex = idx >= 0 ? idx : toContainer.items.length;\n      const activeRect = (_active$rect = active.rect) === null || _active$rect === void 0 ? void 0 : (_active$rect$current = _active$rect.current) === null || _active$rect$current === void 0 ? void 0 : _active$rect$current.translated;\n      const overRect = over.rect;\n      const isBelow = activeRect && overRect ? activeRect.top > overRect.top + overRect.height / 2 : false;\n      toIndex = toIndex + (isBelow ? 1 : 0);\n    }\n    if (fromId === toId && !overInstanceId) return;\n    if (overInstanceId === instanceId) return;\n    if (fromId === toId) {\n      if (toIndex === fromIndex) return;\n      const nextItems = arrayMove(fromContainer.items, fromIndex, toIndex);\n      containersDraftRef.current = draft.map(c => c.id === fromId ? {\n        ...c,\n        items: nextItems\n      } : c);\n      dispatch(softTickAction());\n      return;\n    }\n    const nextFromItems = fromContainer.items.filter(id => id !== instanceId);\n    const clamped = Math.max(0, Math.min(toContainer.items.length, toIndex));\n    const nextToItems = [...toContainer.items];\n    nextToItems.splice(clamped, 0, instanceId);\n    containersDraftRef.current = draft.map(c => {\n      if (c.id === fromId) return {\n        ...c,\n        items: nextFromItems\n      };\n      if (c.id === toId) return {\n        ...c,\n        items: nextToItems\n      };\n      return c;\n    });\n    dispatch(softTickAction());\n  }, [dispatch, state.panels]);\n  const handleDragEnd = useCallback(event => {\n    var _active$data$current$3, _active$data3, _active$data3$current;\n    dispatch(setDebugEventAction(pickEvent(event, \"end\")));\n    const {\n      active,\n      over\n    } = event;\n    const activeRole = (_active$data$current$3 = active === null || active === void 0 ? void 0 : (_active$data3 = active.data) === null || _active$data3 === void 0 ? void 0 : (_active$data3$current = _active$data3.current) === null || _active$data3$current === void 0 ? void 0 : _active$data3$current.role) !== null && _active$data$current$3 !== void 0 ? _active$data$current$3 : null;\n    dispatch(setActiveIdAction(null));\n    dispatch(setActiveSizeAction(null));\n\n    // ======================================================\n    // ✅ CONTAINER SORT END: persist panel once\n    // ======================================================\n    if (activeRole === \"container\") {\n      var _ref2, _ref3, _containerSortPanelId, _active$data4, _active$data4$current, _over$data5, _over$data5$current, _findPanelByContainer2;\n      if (!over) return;\n      const panelId = (_ref2 = (_ref3 = (_containerSortPanelId = containerSortPanelIdRef.current) !== null && _containerSortPanelId !== void 0 ? _containerSortPanelId : (_active$data4 = active.data) === null || _active$data4 === void 0 ? void 0 : (_active$data4$current = _active$data4.current) === null || _active$data4$current === void 0 ? void 0 : _active$data4$current.panelId) !== null && _ref3 !== void 0 ? _ref3 : (_over$data5 = over.data) === null || _over$data5 === void 0 ? void 0 : (_over$data5$current = _over$data5.current) === null || _over$data5$current === void 0 ? void 0 : _over$data5$current.panelId) !== null && _ref2 !== void 0 ? _ref2 : (_findPanelByContainer2 = findPanelByContainerId(active.id, state.panels || [])) === null || _findPanelByContainer2 === void 0 ? void 0 : _findPanelByContainer2.id;\n      if (!panelId) return;\n      const panel = (state.panels || []).find(p => p.id === panelId);\n      if (!panel) return;\n      socket === null || socket === void 0 ? void 0 : socket.emit(\"update_panel\", {\n        panel,\n        gridId: panel.gridId\n      });\n\n      // cleanup\n      containerSortPanelIdRef.current = null;\n      return;\n    }\n\n    // ======================================================\n    // INSTANCE SORT END (your existing commit logic)\n    // ======================================================\n    if (!over) {\n      containersDraftRef.current = null;\n      dispatch(softTickAction());\n      return;\n    }\n    const draft = containersDraftRef.current;\n\n    // commit locally + persist\n    if (draft) {\n      dispatch(setContainersAction(draft));\n\n      // emit ONLY containers that changed\n      const prev = state.containers;\n      for (const nextC of draft) {\n        var _prevC$items;\n        const prevC = (prev || []).find(c => c.id === nextC.id);\n        const prevItems = (_prevC$items = prevC === null || prevC === void 0 ? void 0 : prevC.items) !== null && _prevC$items !== void 0 ? _prevC$items : [];\n        if (!itemsEqual(prevItems, nextC.items)) {\n          socket === null || socket === void 0 ? void 0 : socket.emit(\"update_container_items\", {\n            containerId: nextC.id,\n            items: nextC.items\n          });\n        }\n      }\n      containersDraftRef.current = null;\n      dispatch(softTickAction());\n    }\n  }, [dispatch, socket, state.containers, state.panels]);\n  return useMemo(() => ({\n    handleDragStart,\n    handleDragOver,\n    handleDragEnd,\n    handleDragCancel,\n    containersDraftRef,\n    getWorkingContainers\n  }), [handleDragStart, handleDragOver, handleDragEnd, handleDragCancel, getWorkingContainers]);\n}\n_s(useDndReorderCoordinator, \"MB54V46carNZWpK2LqVw8nSaiJU=\");","map":{"version":3,"names":["useCallback","useMemo","useRef","createContainerAction","createInstanceInContainerAction","setActiveIdAction","setActiveSizeAction","setContainersAction","setDebugEventAction","softTickAction","updatePanelAction","uid","Date","now","toString","Math","random","slice","arrayMove","arr","from","to","copy","item","splice","deepCloneContainers","containers","map","c","items","pickEvent","event","type","_a$data","_o$data","_activeData$role","_activeData$container","_activeData$panelId","_overData$role","_overData$containerId","_overData$panelId","a","active","o","over","activeData","data","current","overData","ts","id","role","containerId","panelId","getOverContainerId","_over$data","_over$data$current","cid","startsWith","length","findPanelByContainerId","panels","find","p","includes","findContainerByInstanceId","instanceId","list","itemsEqual","b","i","useDndReorderCoordinator","state","dispatch","socket","_s","containersDraftRef","lastOverRef","activeId","overId","overRole","overContainerId","lastContainerSortRef","activeContainerId","containerSortPanelIdRef","getWorkingContainers","_containersDraftRef$c","handleDragStart","_event$active$rect","_event$active$rect$cu","rect","initial","width","height","handleDragCancel","handleDragOver","_over$data$current$ro","_over$data2","_over$data2$current","_over$data$current$co","_over$data3","_over$data3$current","_active$data$current$","_active$data","_active$data$current","nextOverRole","nextOverContainerId","last","sameOver","activeRole","_ref","_active$data$current$2","_active$data2","_active$data2$current","_over$data4","_over$data4$current","_findPanelByContainer","panel","ids","fromIndex","indexOf","toIndex","lastC","nextIds","draft","fromContainer","toContainerId","toContainer","fromId","toId","isOverInstance","overInstanceId","_active$rect","_active$rect$current","idx","activeRect","translated","overRect","isBelow","top","nextItems","nextFromItems","filter","clamped","max","min","nextToItems","handleDragEnd","_active$data$current$3","_active$data3","_active$data3$current","_ref2","_ref3","_containerSortPanelId","_active$data4","_active$data4$current","_over$data5","_over$data5$current","_findPanelByContainer2","emit","gridId","prev","nextC","_prevC$items","prevC","prevItems"],"sources":["/home/joshpoms/dndtest2/client/src/helpers/useDndReorderCoordinator.js"],"sourcesContent":["// dnd/useDndReorderCoordinator.js\nimport { useCallback, useMemo, useRef } from \"react\";\nimport {\n  createContainerAction,\n  createInstanceInContainerAction,\n  setActiveIdAction,\n  setActiveSizeAction,\n  setContainersAction,\n  setDebugEventAction,\n  softTickAction,\n\n  // ✅ ADD: panel updates for container sorting\n  updatePanelAction,\n} from \"../state/actions\";\n\n// ---------- utilities ----------\nfunction uid() {\n  return Date.now().toString(36) + Math.random().toString(36).slice(2, 10);\n}\n\nfunction arrayMove(arr, from, to) {\n  const copy = [...arr];\n  const [item] = copy.splice(from, 1);\n  copy.splice(to, 0, item);\n  return copy;\n}\n\nfunction deepCloneContainers(containers) {\n  return (containers || []).map((c) => ({ ...c, items: [...(c.items || [])] }));\n}\n\n// ✅ Safe event snapshot for debug UI (no circular refs)\nfunction pickEvent(event, type) {\n  const a = event?.active;\n  const o = event?.over;\n\n  const activeData = a?.data?.current || null;\n  const overData = o?.data?.current || null;\n\n  return {\n    type,\n    ts: Date.now(),\n    active: a\n      ? {\n          id: a.id,\n          role: activeData?.role ?? null,\n          containerId: activeData?.containerId ?? null,\n          panelId: activeData?.panelId ?? null, // ✅ helpful for debugging\n          data: activeData,\n        }\n      : null,\n    over: o\n      ? {\n          id: o.id,\n          role: overData?.role ?? null,\n          containerId: overData?.containerId ?? null,\n          panelId: overData?.panelId ?? null, // ✅ helpful for debugging\n          data: overData,\n        }\n      : null,\n  };\n}\n\nfunction getOverContainerId(over) {\n  if (!over) return null;\n\n  // preferred: explicit data\n  const cid = over.data?.current?.containerId;\n  if (cid) return cid;\n\n  // fallback: parse droppable id patterns (list:/top:/bottom:)\n  if (typeof over.id === \"string\") {\n    if (over.id.startsWith(\"list:\")) return over.id.slice(\"list:\".length);\n    if (over.id.startsWith(\"top:\")) return over.id.slice(\"top:\".length);\n    if (over.id.startsWith(\"bottom:\")) return over.id.slice(\"bottom:\".length);\n  }\n\n  return null;\n}\n\nfunction findPanelByContainerId(containerId, panels = []) {\n  return (panels || []).find((p) => (p.containers || []).includes(containerId));\n}\n\nfunction findContainerByInstanceId(instanceId, list) {\n  return (list || []).find((c) => (c.items || []).includes(instanceId));\n}\n\nfunction itemsEqual(a = [], b = []) {\n  if (a === b) return true;\n  if (!a || !b) return false;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n  return true;\n}\n\n// ---------- hook ----------\nexport function useDndReorderCoordinator({ state, dispatch, socket }) {\n  // soft-sort draft ref (kept out of reducer on purpose)\n  const containersDraftRef = useRef(null);\n\n  const lastOverRef = useRef({\n    activeId: null,\n    overId: null,\n    overRole: null,\n    overContainerId: null,\n  });\n\n  // ✅ prevent container sort spam\n  const lastContainerSortRef = useRef({\n    panelId: null,\n    activeContainerId: null,\n    overContainerId: null,\n  });\n\n  // ✅ track which panel got reordered, so dragEnd can persist once\n  const containerSortPanelIdRef = useRef(null);\n\n  const getWorkingContainers = useCallback(() => {\n    return containersDraftRef.current ?? state.containers;\n  }, [state.containers]);\n\n  const handleDragStart = useCallback(\n    (event) => {\n      dispatch(setDebugEventAction(pickEvent(event, \"start\")));\n      dispatch(setActiveIdAction(event.active.id));\n\n      const rect = event.active.rect?.current?.initial;\n      if (rect) dispatch(setActiveSizeAction({ width: rect.width, height: rect.height }));\n\n      // ✅ only needed for instance sorting; harmless to set always\n      containersDraftRef.current = deepCloneContainers(state.containers);\n\n      lastOverRef.current = {\n        activeId: event.active.id,\n        overId: null,\n        overRole: null,\n        overContainerId: null,\n      };\n\n      lastContainerSortRef.current = {\n        panelId: null,\n        activeContainerId: null,\n        overContainerId: null,\n      };\n      containerSortPanelIdRef.current = null;\n\n      dispatch(softTickAction());\n    },\n    [dispatch, state.containers]\n  );\n\n  const handleDragCancel = useCallback(() => {\n    dispatch(setDebugEventAction({ type: \"cancel\", ts: Date.now() }));\n    dispatch(setActiveIdAction(null));\n    dispatch(setActiveSizeAction(null));\n\n    containersDraftRef.current = null;\n    containerSortPanelIdRef.current = null;\n\n    dispatch(softTickAction());\n  }, [dispatch]);\n\n  const handleDragOver = useCallback(\n    (event) => {\n      const { active, over } = event;\n      if (!over) return;\n\n      const nextOverRole = over.data?.current?.role ?? null;\n      const nextOverContainerId =\n        over.data?.current?.containerId ??\n        (typeof over.id === \"string\" ? over.id : null);\n\n      const last = lastOverRef.current;\n      const sameOver =\n        last.activeId === active.id &&\n        last.overId === over.id &&\n        last.overRole === nextOverRole &&\n        last.overContainerId === nextOverContainerId;\n\n      if (!sameOver) {\n        lastOverRef.current = {\n          activeId: active.id,\n          overId: over.id,\n          overRole: nextOverRole,\n          overContainerId: nextOverContainerId,\n        };\n        dispatch(setDebugEventAction(pickEvent(event, \"over\")));\n      }\n\n      const activeRole = active.data?.current?.role ?? null;\n      const overRole = nextOverRole;\n\n      // ======================================================\n      // ✅ CONTAINER SORT (inside a panel)\n      // ======================================================\n      if (activeRole === \"container\") {\n        // Only when hovering another container tile\n        if (overRole !== \"container\") return;\n\n        const activeContainerId = active.id;\n        const overContainerId = over.id;\n\n        // Determine panel\n        const panelId =\n          active.data?.current?.panelId ??\n          over.data?.current?.panelId ??\n          findPanelByContainerId(activeContainerId, state.panels || [])?.id;\n\n        if (!panelId) return;\n\n        const panel = (state.panels || []).find((p) => p.id === panelId);\n        if (!panel) return;\n\n        const ids = panel.containers || [];\n        const fromIndex = ids.indexOf(activeContainerId);\n        const toIndex = ids.indexOf(overContainerId);\n\n        if (fromIndex === -1 || toIndex === -1) return;\n        if (fromIndex === toIndex) return;\n\n        // de-dupe\n        const lastC = lastContainerSortRef.current;\n        if (\n          lastC.panelId === panelId &&\n          lastC.activeContainerId === activeContainerId &&\n          lastC.overContainerId === overContainerId\n        ) {\n          return;\n        }\n        lastContainerSortRef.current = { panelId, activeContainerId, overContainerId };\n\n        const nextIds = arrayMove(ids, fromIndex, toIndex);\n\n        // ✅ update panel order immediately so rectSortingStrategy animates\n        dispatch(updatePanelAction({ ...panel, containers: nextIds }));\n\n        containerSortPanelIdRef.current = panelId;\n        dispatch(softTickAction());\n        return;\n      }\n\n      // ======================================================\n      // INSTANCE SORT (your existing logic)\n      // ======================================================\n      const draft = containersDraftRef.current;\n      if (!draft) return;\n\n      if (activeRole !== \"instance\") return;\n\n      const instanceId = active.id;\n\n      const fromContainer = findContainerByInstanceId(instanceId, draft);\n      if (!fromContainer) return;\n\n      const toContainerId = getOverContainerId(over);\n      if (!toContainerId) return;\n\n      const toContainer = draft.find((c) => c.id === toContainerId);\n      if (!toContainer) return;\n\n      const fromId = fromContainer.id;\n      const toId = toContainer.id;\n\n      const fromIndex = fromContainer.items.indexOf(instanceId);\n      if (fromIndex === -1) return;\n\n      const isOverInstance = overRole === \"instance\";\n      const overInstanceId = isOverInstance ? over.id : null;\n\n      let toIndex;\n      if (!overInstanceId) {\n        toIndex = toContainer.items.length;\n      } else {\n        const idx = toContainer.items.indexOf(overInstanceId);\n        toIndex = idx >= 0 ? idx : toContainer.items.length;\n\n        const activeRect = active.rect?.current?.translated;\n        const overRect = over.rect;\n        const isBelow =\n          activeRect && overRect\n            ? activeRect.top > overRect.top + overRect.height / 2\n            : false;\n\n        toIndex = toIndex + (isBelow ? 1 : 0);\n      }\n\n      if (fromId === toId && !overInstanceId) return;\n      if (overInstanceId === instanceId) return;\n\n      if (fromId === toId) {\n        if (toIndex === fromIndex) return;\n\n        const nextItems = arrayMove(fromContainer.items, fromIndex, toIndex);\n\n        containersDraftRef.current = draft.map((c) =>\n          c.id === fromId ? { ...c, items: nextItems } : c\n        );\n\n        dispatch(softTickAction());\n        return;\n      }\n\n      const nextFromItems = fromContainer.items.filter((id) => id !== instanceId);\n\n      const clamped = Math.max(0, Math.min(toContainer.items.length, toIndex));\n      const nextToItems = [...toContainer.items];\n      nextToItems.splice(clamped, 0, instanceId);\n\n      containersDraftRef.current = draft.map((c) => {\n        if (c.id === fromId) return { ...c, items: nextFromItems };\n        if (c.id === toId) return { ...c, items: nextToItems };\n        return c;\n      });\n\n      dispatch(softTickAction());\n    },\n    [dispatch, state.panels]\n  );\n\n  const handleDragEnd = useCallback(\n    (event) => {\n      dispatch(setDebugEventAction(pickEvent(event, \"end\")));\n\n      const { active, over } = event;\n      const activeRole = active?.data?.current?.role ?? null;\n\n      dispatch(setActiveIdAction(null));\n      dispatch(setActiveSizeAction(null));\n\n      // ======================================================\n      // ✅ CONTAINER SORT END: persist panel once\n      // ======================================================\n      if (activeRole === \"container\") {\n        if (!over) return;\n\n        const panelId =\n          containerSortPanelIdRef.current ??\n          active.data?.current?.panelId ??\n          over.data?.current?.panelId ??\n          findPanelByContainerId(active.id, state.panels || [])?.id;\n\n        if (!panelId) return;\n\n        const panel = (state.panels || []).find((p) => p.id === panelId);\n        if (!panel) return;\n\n        socket?.emit(\"update_panel\", { panel, gridId: panel.gridId });\n\n        // cleanup\n        containerSortPanelIdRef.current = null;\n        return;\n      }\n\n      // ======================================================\n      // INSTANCE SORT END (your existing commit logic)\n      // ======================================================\n      if (!over) {\n        containersDraftRef.current = null;\n        dispatch(softTickAction());\n        return;\n      }\n\n      const draft = containersDraftRef.current;\n\n      // commit locally + persist\n      if (draft) {\n        dispatch(setContainersAction(draft));\n\n        // emit ONLY containers that changed\n        const prev = state.containers;\n        for (const nextC of draft) {\n          const prevC = (prev || []).find((c) => c.id === nextC.id);\n          const prevItems = prevC?.items ?? [];\n          if (!itemsEqual(prevItems, nextC.items)) {\n            socket?.emit(\"update_container_items\", {\n              containerId: nextC.id,\n              items: nextC.items,\n            });\n          }\n        }\n\n        containersDraftRef.current = null;\n        dispatch(softTickAction());\n      }\n    },\n    [dispatch, socket, state.containers, state.panels]\n  );\n\n  return useMemo(\n    () => ({\n      handleDragStart,\n      handleDragOver,\n      handleDragEnd,\n      handleDragCancel,\n      containersDraftRef,\n      getWorkingContainers,\n    }),\n    [\n      handleDragStart,\n      handleDragOver,\n      handleDragEnd,\n      handleDragCancel,\n      getWorkingContainers,\n    ]\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}