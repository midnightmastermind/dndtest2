{"ast":null,"code":"import * as React from 'react';\nimport { createContext, useContext } from 'react';\nimport { isCacheDisabled } from './cache';\nimport { isServerEnvironment } from './is-server-environment';\n/**\n * Cache to hold already used styles.\n * React Context on the server - singleton object on the client.\n */\nconst Cache = isServerEnvironment() ? createContext(null) : {};\nif (!isServerEnvironment() && typeof document !== 'undefined') {\n  /**\n   * Iterates through all found style elements generated when server side rendering.\n   *\n   * @param cb\n   */\n  const ssrStyles = document.querySelectorAll('style[data-cmpld]');\n  for (let i = 0; i < ssrStyles.length; i++) {\n    // Move all found server-side rendered style elements to the head before React hydration happens.\n    document.head.appendChild(ssrStyles[i]);\n  }\n}\n/**\n * Hook using the cache created on the server or client.\n */\nexport const useCache = () => {\n  if (false) {\n    return {};\n  }\n  if (isServerEnvironment()) {\n    // On the server we use React Context to we don't leak the cache between SSR calls.\n    // During runtime this hook isn't conditionally called - it is at build time that the flow gets decided.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useContext(Cache) || {};\n  }\n  // On the client we use the object singleton.\n  return Cache;\n};\n/**\n * On the server this ensures the minimal amount of styles will be rendered\n * safely using React Context.\n *\n * On the browser this turns into a fragment with no React Context.\n */\nconst StyleCacheProvider = props => {\n  if (isServerEnvironment()) {\n    // This code path isn't conditionally called at build time - safe to ignore.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const inserted = useCache();\n    return React.createElement(Cache.Provider, {\n      value: inserted\n    }, props.children);\n  }\n  return props.children;\n};\nexport default StyleCacheProvider;","map":{"version":3,"names":["React","createContext","useContext","isCacheDisabled","isServerEnvironment","Cache","document","ssrStyles","querySelectorAll","i","length","head","appendChild","useCache","StyleCacheProvider","props","inserted","createElement","Provider","value","children"],"sources":["/data/data/com.termux/files/home/dndkittest2/client/node_modules/@compiled/react/src/runtime/style-cache.tsx"],"sourcesContent":["import * as React from 'react';\nimport { createContext, useContext } from 'react';\n\nimport { isCacheDisabled } from './cache';\nimport { isServerEnvironment } from './is-server-environment';\nimport type { ProviderComponent, UseCacheHook } from './types';\n\n/**\n * Cache to hold already used styles.\n * React Context on the server - singleton object on the client.\n */\nconst Cache: any = isServerEnvironment() ? createContext<Record<string, true> | null>(null) : {};\n\nif (!isServerEnvironment() && typeof document !== 'undefined') {\n  /**\n   * Iterates through all found style elements generated when server side rendering.\n   *\n   * @param cb\n   */\n  const ssrStyles = document.querySelectorAll<HTMLStyleElement>('style[data-cmpld]');\n  for (let i = 0; i < ssrStyles.length; i++) {\n    // Move all found server-side rendered style elements to the head before React hydration happens.\n    document.head.appendChild(ssrStyles[i]);\n  }\n}\n\n/**\n * Hook using the cache created on the server or client.\n */\nexport const useCache: UseCacheHook = () => {\n  if (isCacheDisabled()) {\n    return {};\n  }\n\n  if (isServerEnvironment()) {\n    // On the server we use React Context to we don't leak the cache between SSR calls.\n    // During runtime this hook isn't conditionally called - it is at build time that the flow gets decided.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useContext(Cache) || {};\n  }\n\n  // On the client we use the object singleton.\n  return Cache;\n};\n\n/**\n * On the server this ensures the minimal amount of styles will be rendered\n * safely using React Context.\n *\n * On the browser this turns into a fragment with no React Context.\n */\nconst StyleCacheProvider: ProviderComponent = (props) => {\n  if (isServerEnvironment()) {\n    // This code path isn't conditionally called at build time - safe to ignore.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const inserted = useCache();\n    return <Cache.Provider value={inserted}>{props.children}</Cache.Provider>;\n  }\n\n  return props.children as JSX.Element;\n};\n\nexport default StyleCacheProvider;\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,aAAa,EAAEC,UAAU,QAAQ,OAAO;AAEjD,SAASC,eAAe,QAAQ,SAAS;AACzC,SAASC,mBAAmB,QAAQ,yBAAyB;AAG7D;;;;AAIA,MAAMC,KAAK,GAAQD,mBAAmB,EAAE,GAAGH,aAAa,CAA8B,IAAI,CAAC,GAAG,EAAE;AAEhG,IAAI,CAACG,mBAAmB,EAAE,IAAI,OAAOE,QAAQ,KAAK,WAAW,EAAE;EAC7D;;;;;EAKA,MAAMC,SAAS,GAAGD,QAAQ,CAACE,gBAAgB,CAAmB,mBAAmB,CAAC;EAClF,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IACzC;IACAH,QAAQ,CAACK,IAAI,CAACC,WAAW,CAACL,SAAS,CAACE,CAAC,CAAC,CAAC;;;AAI3C;;;AAGA,OAAO,MAAMI,QAAQ,GAAiBA,CAAA,KAAK;EACzC,WAAuB;IACrB,OAAO,EAAE;;EAGX,IAAIT,mBAAmB,EAAE,EAAE;IACzB;IACA;IACA;IACA,OAAOF,UAAU,CAACG,KAAK,CAAC,IAAI,EAAE;;EAGhC;EACA,OAAOA,KAAK;AACd,CAAC;AAED;;;;;;AAMA,MAAMS,kBAAkB,GAAuBC,KAAK,IAAI;EACtD,IAAIX,mBAAmB,EAAE,EAAE;IACzB;IACA;IACA,MAAMY,QAAQ,GAAGH,QAAQ,EAAE;IAC3B,OAAOb,KAAA,CAAAiB,aAAA,CAACZ,KAAK,CAACa,QAAQ;MAACC,KAAK,EAAEH;IAAQ,GAAGD,KAAK,CAACK,QAAQ,CAAkB;;EAG3E,OAAOL,KAAK,CAACK,QAAuB;AACtC,CAAC;AAED,eAAeN,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}