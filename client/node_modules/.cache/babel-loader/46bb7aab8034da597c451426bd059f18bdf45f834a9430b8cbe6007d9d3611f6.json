{"ast":null,"code":"import { ax } from '../runtime';\n/**\n * ## CX\n *\n * Use in conjunction with the {@link XCSSProp} to concatenate and conditionally apply\n * declared styles. Can only be used with the `cssMap()` and {@link XCSSProp} APIs.\n *\n * @example\n * ```\n * const styles = cssMap({\n *  text: { color: 'var(--ds-text)' },\n *  primary: { color: 'var(--ds-text-brand)' },\n * });\n *\n * <Component xcss={cx(isPrimary && styles.text, !isPrimary && styles.primary)} />\n * ```\n */\nexport const cx = (...styles) => {\n  // At runtime TStyles is resolved down to strings, but not at compile time.\n  // We circumvent the type system here because of that.\n  const actualStyles = styles;\n  // The output should be a union type of passed in styles. This ensures the call\n  // site of xcss prop can raise violations when disallowed styles have been passed.\n  return ax(actualStyles);\n};","map":{"version":3,"names":["ax","cx","styles","actualStyles"],"sources":["/home/joshpoms/dndtest2/client/node_modules/@compiled/react/src/xcss-prop/index.ts"],"sourcesContent":["import type * as CSS from 'csstype';\n\nimport type { ApplySchemaValue } from '../create-strict-api/types';\nimport { ax } from '../runtime';\nimport type { CSSPseudos, CSSProperties, StrictCSSProperties, AllCSSPseudoClasses } from '../types';\n\ntype MarkAsRequired<T, K extends keyof T> = T & { [P in K]-?: T[P] };\n\ntype XCSSValue<\n  TStyleDecl extends keyof CSSProperties,\n  TSchema,\n  TPseudoKey extends AllCSSPseudoClasses | ''\n> = {\n  [Q in keyof StrictCSSProperties]: Q extends TStyleDecl\n    ? ApplySchemaValue<TSchema, Q, TPseudoKey>\n    : never;\n};\n\ntype XCSSPseudo<\n  TAllowedProperties extends keyof StrictCSSProperties,\n  TAllowedPseudos extends CSSPseudos,\n  TRequiredProperties extends { requiredProperties: TAllowedProperties },\n  TSchema\n> = {\n  [Q in CSSPseudos]?: Q extends TAllowedPseudos\n    ? MarkAsRequired<\n        XCSSValue<TAllowedProperties, TSchema, Q extends AllCSSPseudoClasses ? Q : ''>,\n        TRequiredProperties['requiredProperties']\n      >\n    : never;\n};\n\ntype XCSSMediaQuery<\n  TAllowedProperties extends keyof StrictCSSProperties,\n  TAllowedPseudos extends CSSPseudos,\n  TAllowedMediaQueries extends string,\n  TSchema\n> = {\n  [Q in `@media ${TAllowedMediaQueries}`]?:\n    | XCSSValue<TAllowedProperties, TSchema, ''>\n    | XCSSPseudo<TAllowedProperties, TAllowedPseudos, never, TSchema>;\n};\n\n/**\n * These APIs we don't want to allow to be passed through the `xcss` prop but we also\n * must declare them so the (lack-of a) excess property check doesn't bite us and allow\n * unexpected values through.\n */\ntype BlockedRules<TMode extends 'loose' | 'strict'> = {\n  // To ensure styles that aren't allowed through XCSS prop strict APIs we block any\n  // loose media queries from being passed through as we can't ensure they're correct.\n  '@media [loose]'?: TMode extends 'loose' ? any : never;\n  selectors?: never;\n} & {\n  // We also block all type level at rule \"objects\" that are present on cssMap.\n  [Q in CSS.AtRules]?: never;\n};\n\ntype CompiledPropertyDeclarationReference = {\n  ['__COMPILED_PROPERTY_DECLARATION_REFERENCE_DO_NOT_WRITE_DIRECTLY__']: true;\n};\n\n/**\n * Used to mark styles that have been flushed through an API as being generated\n * from Compiled. This is useful when you want other ends of the API to ensure they\n * take Compiled generated styles and not some arbitrary object.\n */\nexport type CompiledStyles<TObject> = {\n  [Q in keyof TObject]: TObject[Q] extends Record<string, unknown>\n    ? CompiledStyles<TObject[Q]>\n    : CompiledPropertyDeclarationReference & TObject[Q];\n};\n\n/**\n * Please think twice before using this type, you're better off declaring explicitly\n * what your API should be, for example only defining `\"color\"`.\n *\n * Use in conjunction with {@link XCSSProp} to allow all properties to be given to\n * your component.\n */\nexport type XCSSAllProperties = keyof StrictCSSProperties;\n\n/**\n * Please think twice before using this type, you're better off declaring explicitly\n * what your API should be, for example not allowing any pseudos at all using the\n * `never` type.\n *\n * Use in conjunction with {@link XCSSProp} to allow all pseudos to be given to\n * your component.\n */\nexport type XCSSAllPseudos = CSSPseudos;\n\n/**\n * ## XCSSProp\n *\n * Declare styles your component takes with all other styles marked as violations\n * by the TypeScript compiler. There are two primary use cases for xcss prop:\n *\n * - safe style overrides\n * - inverting style declarations\n *\n * Interverting style declarations is interesting for platform teams as\n * it means products only pay for styles they use as they're now the ones who declare\n * the styles!\n *\n * The {@link XCSSProp} type has generics two of which must be defined â€” use to explicitly\n * set want you to maintain as API. Use {@link XCSSAllProperties} and {@link XCSSAllPseudos}\n * to enable all properties and pseudos.\n *\n * The third generic is used to declare what properties and pseudos should be required.\n *\n * @example\n * ```\n * interface MyComponentProps {\n *   // Color is accepted, all other properties / pseudos are considered violations.\n *   xcss?: XCSSProp<'color', never>;\n *\n *   // Only backgrond color and hover pseudo is accepted.\n *   xcss?: XCSSProp<'backgroundColor', '&:hover'>;\n *\n *   // All properties are accepted, all pseudos are considered violations.\n *   xcss?: XCSSProp<XCSSAllProperties, never>;\n *\n *   // All properties are accepted, only the hover pseudo is accepted.\n *   xcss?: XCSSProp<XCSSAllProperties, '&:hover'>;\n *\n *   // The xcss prop is required as well as the color property. No pseudos are required.\n *   xcss: XCSSProp<XCSSAllProperties, '&:hover', { requiredProperties: 'color' }>;\n * }\n *\n * function MyComponent({ xcss }: MyComponentProps) {\n *   return <div css={{ color: 'var(--ds-text-danger)' }} className={xcss} />\n * }\n * ```\n *\n * The xcss prop works with static inline objects and the [cssMap](https://compiledcssinjs.com/docs/api-cssmap) API.\n *\n * @example\n * ```\n * // Declared as an inline object\n * <Component xcss={{ color: 'var(--ds-text)' }} />\n *\n * // Declared with the cssMap API\n * const styles = cssMap({ text: { color: 'var(--ds-text)' } });\n * <Component xcss={styles.text} />\n * ```\n *\n * To concatenate and conditonally apply styles use the {@link cssMap} {@link cx} functions.\n */\nexport type XCSSProp<\n  TAllowedProperties extends keyof StrictCSSProperties,\n  TAllowedPseudos extends CSSPseudos,\n  TRequiredProperties extends {\n    requiredProperties: TAllowedProperties;\n  } = never\n> = Internal$XCSSProp<\n  TAllowedProperties,\n  TAllowedPseudos,\n  string,\n  object,\n  TRequiredProperties,\n  'loose'\n>;\n\nexport type Internal$XCSSProp<\n  TAllowedProperties extends keyof StrictCSSProperties,\n  TAllowedPseudos extends CSSPseudos,\n  TAllowedMediaQueries extends string,\n  TSchema,\n  TRequiredProperties extends {\n    requiredProperties: TAllowedProperties;\n  },\n  TMode extends 'loose' | 'strict'\n> =\n  | (MarkAsRequired<\n      XCSSValue<TAllowedProperties, TSchema, ''>,\n      TRequiredProperties['requiredProperties']\n    > &\n      XCSSPseudo<TAllowedProperties, TAllowedPseudos, TRequiredProperties, TSchema> &\n      XCSSMediaQuery<TAllowedProperties, TAllowedPseudos, TAllowedMediaQueries, TSchema> &\n      BlockedRules<TMode>)\n  | false\n  | null\n  | undefined;\n\n/**\n * ## CX\n *\n * Use in conjunction with the {@link XCSSProp} to concatenate and conditionally apply\n * declared styles. Can only be used with the `cssMap()` and {@link XCSSProp} APIs.\n *\n * @example\n * ```\n * const styles = cssMap({\n *  text: { color: 'var(--ds-text)' },\n *  primary: { color: 'var(--ds-text-brand)' },\n * });\n *\n * <Component xcss={cx(isPrimary && styles.text, !isPrimary && styles.primary)} />\n * ```\n */\nexport const cx = <TStyles extends [...XCSSProp<any, any>[]]>(\n  ...styles: TStyles\n): TStyles[number] => {\n  // At runtime TStyles is resolved down to strings, but not at compile time.\n  // We circumvent the type system here because of that.\n  const actualStyles = styles as unknown as string[];\n\n  // The output should be a union type of passed in styles. This ensures the call\n  // site of xcss prop can raise violations when disallowed styles have been passed.\n  return ax(actualStyles) as TStyles[number];\n};\n"],"mappings":"AAGA,SAASA,EAAE,QAAQ,YAAY;AAsL/B;;;;;;;;;;;;;;;;AAgBA,OAAO,MAAMC,EAAE,GAAGA,CAChB,GAAGC,MAAe,KACC;EACnB;EACA;EACA,MAAMC,YAAY,GAAGD,MAA6B;EAElD;EACA;EACA,OAAOF,EAAE,CAACG,YAAY,CAAoB;AAC5C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}