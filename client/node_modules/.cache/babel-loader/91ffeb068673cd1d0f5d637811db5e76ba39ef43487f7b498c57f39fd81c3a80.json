{"ast":null,"code":"/**\n * This length includes the underscore,\n * e.g. `\"_1s4A\"` would be a valid atomic group hash.\n */\nconst ATOMIC_GROUP_LENGTH = 5;\n/**\n * Create a single string containing all the classnames provided, separated by a space (`\" \"`).\n * The result will only contain the _last_ atomic style classname for each atomic `group`.\n *\n * ```ts\n * ax(['_aaaabbbb', '_aaaacccc']);\n * // output\n * '_aaaacccc'\n * ```\n *\n * Format of Atomic style classnames: `_{group}{value}` (`_\\w{4}\\w{4}`)\n *\n * `ax` will preserve any non atomic style classnames (eg `\"border-red\"`)\n *\n * ```ts\n * ax(['_aaaabbbb', '_aaaacccc', 'border-red']);\n * // output\n * '_aaaacccc border-red'\n * ```\n */\nexport default function ax(classNames) {\n  // Shortcut: nothing to do\n  if (!classNames.length) {\n    return;\n  }\n  // Shortcut: don't need to do anything if we only have a single classname\n  if (classNames.length === 1 && classNames[0] &&\n  // checking to see if `classNames[0]` is a string that contains other classnames\n  !classNames[0].includes(' ')) {\n    return classNames[0];\n  }\n  // Using an object rather than a `Map` as it performed better in our benchmarks.\n  // Would be happy to move to `Map` if it proved to be better under real conditions.\n  const map = {};\n  // Note: using loops to minimize iterations over the collection\n  for (const value of classNames) {\n    // Exclude all falsy values, which leaves us with populated strings\n    if (!value) {\n      continue;\n    }\n    // a `value` can contain multiple classnames\n    const list = value.split(' ');\n    for (const className of list) {\n      /**\n       * For atomic style classnames: the `key` is the `group`\n       *\n       * - Later atomic classnames with the same `group` will override earlier ones\n       *   (which is what we want).\n       * - Assumes atomic classnames are the only things that start with `_`\n       * - Could use a regex to ensure that atomic classnames are structured how we expect,\n       *   but did not add that for now as it did slow things down a bit.\n       *\n       * For other classnames: the `key` is the whole classname\n       * - Okay to remove duplicates as doing so does not impact specificity\n       *\n       * */\n      const key = className.startsWith('_') ? className.slice(0, ATOMIC_GROUP_LENGTH) : className;\n      map[key] = className;\n    }\n  }\n  /**\n   * We are converting the `map` into a string.\n   *\n   * The simple way to do this would be `Object.values(map).join(' ')`.\n   * However, the approach below performs 10%-20% better in benchmarks.\n   *\n   * For `ax()` it feels right to squeeze as much runtime performance out as we can.\n   */\n  let result = '';\n  for (const key in map) {\n    result += map[key] + ' ';\n  }\n  // If we have an empty string, then our `map` was empty.\n  if (!result) {\n    return;\n  }\n  // remove last \" \" from the result (we added \" \" at the end of every value)\n  return result.trimEnd();\n}","map":{"version":3,"names":["ATOMIC_GROUP_LENGTH","ax","classNames","length","includes","map","value","list","split","className","key","startsWith","slice","result","trimEnd"],"sources":["/data/data/com.termux/files/home/dndkittest2/client/node_modules/@compiled/react/src/runtime/ax.ts"],"sourcesContent":["/**\n * This length includes the underscore,\n * e.g. `\"_1s4A\"` would be a valid atomic group hash.\n */\nconst ATOMIC_GROUP_LENGTH = 5;\n\n/**\n * Create a single string containing all the classnames provided, separated by a space (`\" \"`).\n * The result will only contain the _last_ atomic style classname for each atomic `group`.\n *\n * ```ts\n * ax(['_aaaabbbb', '_aaaacccc']);\n * // output\n * '_aaaacccc'\n * ```\n *\n * Format of Atomic style classnames: `_{group}{value}` (`_\\w{4}\\w{4}`)\n *\n * `ax` will preserve any non atomic style classnames (eg `\"border-red\"`)\n *\n * ```ts\n * ax(['_aaaabbbb', '_aaaacccc', 'border-red']);\n * // output\n * '_aaaacccc border-red'\n * ```\n */\nexport default function ax(classNames: (string | undefined | null | false)[]): string | undefined {\n  // Shortcut: nothing to do\n  if (!classNames.length) {\n    return;\n  }\n\n  // Shortcut: don't need to do anything if we only have a single classname\n  if (\n    classNames.length === 1 &&\n    classNames[0] &&\n    // checking to see if `classNames[0]` is a string that contains other classnames\n    !classNames[0].includes(' ')\n  ) {\n    return classNames[0];\n  }\n\n  // Using an object rather than a `Map` as it performed better in our benchmarks.\n  // Would be happy to move to `Map` if it proved to be better under real conditions.\n  const map: Record<string, string> = {};\n\n  // Note: using loops to minimize iterations over the collection\n  for (const value of classNames) {\n    // Exclude all falsy values, which leaves us with populated strings\n    if (!value) {\n      continue;\n    }\n\n    // a `value` can contain multiple classnames\n    const list = value.split(' ');\n\n    for (const className of list) {\n      /**\n       * For atomic style classnames: the `key` is the `group`\n       *\n       * - Later atomic classnames with the same `group` will override earlier ones\n       *   (which is what we want).\n       * - Assumes atomic classnames are the only things that start with `_`\n       * - Could use a regex to ensure that atomic classnames are structured how we expect,\n       *   but did not add that for now as it did slow things down a bit.\n       *\n       * For other classnames: the `key` is the whole classname\n       * - Okay to remove duplicates as doing so does not impact specificity\n       *\n       * */\n      const key = className.startsWith('_') ? className.slice(0, ATOMIC_GROUP_LENGTH) : className;\n      map[key] = className;\n    }\n  }\n\n  /**\n   * We are converting the `map` into a string.\n   *\n   * The simple way to do this would be `Object.values(map).join(' ')`.\n   * However, the approach below performs 10%-20% better in benchmarks.\n   *\n   * For `ax()` it feels right to squeeze as much runtime performance out as we can.\n   */\n  let result: string = '';\n  for (const key in map) {\n    result += map[key] + ' ';\n  }\n\n  // If we have an empty string, then our `map` was empty.\n  if (!result) {\n    return;\n  }\n\n  // remove last \" \" from the result (we added \" \" at the end of every value)\n  return result.trimEnd();\n}\n"],"mappings":"AAAA;;;;AAIA,MAAMA,mBAAmB,GAAG,CAAC;AAE7B;;;;;;;;;;;;;;;;;;;;AAoBA,eAAc,SAAUC,EAAEA,CAACC,UAAiD;EAC1E;EACA,IAAI,CAACA,UAAU,CAACC,MAAM,EAAE;IACtB;;EAGF;EACA,IACED,UAAU,CAACC,MAAM,KAAK,CAAC,IACvBD,UAAU,CAAC,CAAC,CAAC;EACb;EACA,CAACA,UAAU,CAAC,CAAC,CAAC,CAACE,QAAQ,CAAC,GAAG,CAAC,EAC5B;IACA,OAAOF,UAAU,CAAC,CAAC,CAAC;;EAGtB;EACA;EACA,MAAMG,GAAG,GAA2B,EAAE;EAEtC;EACA,KAAK,MAAMC,KAAK,IAAIJ,UAAU,EAAE;IAC9B;IACA,IAAI,CAACI,KAAK,EAAE;MACV;;IAGF;IACA,MAAMC,IAAI,GAAGD,KAAK,CAACE,KAAK,CAAC,GAAG,CAAC;IAE7B,KAAK,MAAMC,SAAS,IAAIF,IAAI,EAAE;MAC5B;;;;;;;;;;;;;MAaA,MAAMG,GAAG,GAAGD,SAAS,CAACE,UAAU,CAAC,GAAG,CAAC,GAAGF,SAAS,CAACG,KAAK,CAAC,CAAC,EAAEZ,mBAAmB,CAAC,GAAGS,SAAS;MAC3FJ,GAAG,CAACK,GAAG,CAAC,GAAGD,SAAS;;;EAIxB;;;;;;;;EAQA,IAAII,MAAM,GAAW,EAAE;EACvB,KAAK,MAAMH,GAAG,IAAIL,GAAG,EAAE;IACrBQ,MAAM,IAAIR,GAAG,CAACK,GAAG,CAAC,GAAG,GAAG;;EAG1B;EACA,IAAI,CAACG,MAAM,EAAE;IACX;;EAGF;EACA,OAAOA,MAAM,CAACC,OAAO,EAAE;AACzB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}