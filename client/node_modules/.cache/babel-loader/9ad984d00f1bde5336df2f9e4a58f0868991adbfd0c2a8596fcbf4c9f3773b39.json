{"ast":null,"code":"var _s = $RefreshSig$();\n// dnd/useDndReorderCoordinator.js\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { createContainerAction, createInstanceInContainerAction, setActiveIdAction, setActiveSizeAction, setContainersAction, setDebugEventAction, softTickAction, updatePanelAction } from \"../state/actions\";\n\n// ✅ Schema: who accepts what\nconst ACCEPTS = {\n  panel: [\"container\"],\n  container: [\"instance\"]\n};\n\n// ---------- utilities ----------\nfunction uid() {\n  return Date.now().toString(36) + Math.random().toString(36).slice(2, 10);\n}\nfunction arrayMove(arr, from, to) {\n  const copy = [...arr];\n  const [item] = copy.splice(from, 1);\n  copy.splice(to, 0, item);\n  return copy;\n}\nfunction deepCloneContainers(containers) {\n  return (containers || []).map(c => ({\n    ...c,\n    items: [...(c.items || [])]\n  }));\n}\n\n// ✅ Safe event snapshot for debug UI (no circular refs)\nfunction pickEvent(event, type) {\n  var _a$data, _o$data, _activeData$role, _activeData$container, _activeData$panelId, _overData$role, _overData$containerId, _overData$panelId;\n  const a = event === null || event === void 0 ? void 0 : event.active;\n  const o = event === null || event === void 0 ? void 0 : event.over;\n  const activeData = (a === null || a === void 0 ? void 0 : (_a$data = a.data) === null || _a$data === void 0 ? void 0 : _a$data.current) || null;\n  const overData = (o === null || o === void 0 ? void 0 : (_o$data = o.data) === null || _o$data === void 0 ? void 0 : _o$data.current) || null;\n  return {\n    type,\n    ts: Date.now(),\n    active: a ? {\n      id: a.id,\n      role: (_activeData$role = activeData === null || activeData === void 0 ? void 0 : activeData.role) !== null && _activeData$role !== void 0 ? _activeData$role : null,\n      containerId: (_activeData$container = activeData === null || activeData === void 0 ? void 0 : activeData.containerId) !== null && _activeData$container !== void 0 ? _activeData$container : null,\n      panelId: (_activeData$panelId = activeData === null || activeData === void 0 ? void 0 : activeData.panelId) !== null && _activeData$panelId !== void 0 ? _activeData$panelId : null,\n      data: activeData\n    } : null,\n    over: o ? {\n      id: o.id,\n      role: (_overData$role = overData === null || overData === void 0 ? void 0 : overData.role) !== null && _overData$role !== void 0 ? _overData$role : null,\n      containerId: (_overData$containerId = overData === null || overData === void 0 ? void 0 : overData.containerId) !== null && _overData$containerId !== void 0 ? _overData$containerId : null,\n      panelId: (_overData$panelId = overData === null || overData === void 0 ? void 0 : overData.panelId) !== null && _overData$panelId !== void 0 ? _overData$panelId : null,\n      data: overData\n    } : null\n  };\n}\nfunction itemsEqual(a = [], b = []) {\n  if (a === b) return true;\n  if (!a || !b) return false;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n  return true;\n}\n\n// ---------- generic list move helpers ----------\nfunction removeOne(list = [], id) {\n  const idx = list.indexOf(id);\n  if (idx === -1) return {\n    list,\n    idx: -1\n  };\n  const next = [...list];\n  next.splice(idx, 1);\n  return {\n    list: next,\n    idx\n  };\n}\nfunction insertAt(list = [], id, index) {\n  const next = [...list];\n  const clamped = Math.max(0, Math.min(next.length, index));\n  next.splice(clamped, 0, id);\n  return next;\n}\nfunction moveChildAcrossParents({\n  childId,\n  fromParent,\n  toParent,\n  childKey,\n  toIndex = null\n}) {\n  if (!fromParent || !toParent) return null;\n  const fromList = fromParent[childKey] || [];\n  const toList = toParent[childKey] || [];\n  const {\n    list: fromNext,\n    idx: fromIndex\n  } = removeOne(fromList, childId);\n  if (fromIndex === -1) return null;\n  const insertIndex = toIndex == null ? toList.length : toIndex;\n  const toNext = insertAt(toList, childId, insertIndex);\n  return {\n    nextFromParent: {\n      ...fromParent,\n      [childKey]: fromNext\n    },\n    nextToParent: {\n      ...toParent,\n      [childKey]: toNext\n    },\n    fromIndex\n  };\n}\n\n// ---------- parent finders ----------\nfunction findPanelById(panelId, panels = []) {\n  return (panels || []).find(p => p.id === panelId) || null;\n}\nfunction findPanelByContainerId(containerId, panels = []) {\n  return (panels || []).find(p => (p.containers || []).includes(containerId)) || null;\n}\nfunction findContainerByInstanceId(instanceId, list = []) {\n  return (list || []).find(c => (c.items || []).includes(instanceId)) || null;\n}\nfunction findContainerById(containerId, list = []) {\n  return (list || []).find(c => c.id === containerId) || null;\n}\nfunction canDropInto(parentRole, childRole) {\n  return (ACCEPTS[parentRole] || []).includes(childRole);\n}\n\n/**\n * Normalizes over into:\n *   { parentRole: \"panel\"|\"container\", parentId, overChildId? }\n */\nfunction getOverParent(over) {\n  var _over$data;\n  if (!over) return null;\n  const d = ((_over$data = over.data) === null || _over$data === void 0 ? void 0 : _over$data.current) || {};\n\n  // ✅ Container list/top/bottom => parent is container\n  if (d !== null && d !== void 0 && d.containerId && typeof (d === null || d === void 0 ? void 0 : d.role) === \"string\" && d.role.startsWith(\"container:\")) {\n    return {\n      parentRole: \"container\",\n      parentId: d.containerId\n    };\n  }\n\n  // ✅ Hovering an instance => parent is container\n  if ((d === null || d === void 0 ? void 0 : d.role) === \"instance\" && d !== null && d !== void 0 && d.containerId) {\n    return {\n      parentRole: \"container\",\n      parentId: d.containerId,\n      overChildId: over.id\n    };\n  }\n\n  // ✅ Panel dropzone => parent is panel\n  if ((d === null || d === void 0 ? void 0 : d.role) === \"panel:drop\" && d !== null && d !== void 0 && d.panelId) {\n    return {\n      parentRole: \"panel\",\n      parentId: d.panelId\n    };\n  }\n\n  // ✅ Hovering a container tile => parent is panel (insert relative to that container)\n  if ((d === null || d === void 0 ? void 0 : d.role) === \"container\" && d !== null && d !== void 0 && d.panelId) {\n    return {\n      parentRole: \"panel\",\n      parentId: d.panelId,\n      overChildId: over.id\n    };\n  }\n  return null;\n}\n\n// ---------- hook ----------\nexport function useDndReorderCoordinator({\n  state,\n  dispatch,\n  socket\n}) {\n  _s();\n  // instance soft-sort draft ref (kept out of reducer on purpose)\n  const containersDraftRef = useRef(null);\n  const lastOverRef = useRef({\n    activeId: null,\n    overId: null,\n    overRole: null,\n    overContainerId: null\n  });\n\n  // ✅ de-dupe spam for panel container moves\n  const lastContainerMoveRef = useRef({\n    fromPanelId: null,\n    toPanelId: null,\n    activeContainerId: null,\n    overChildId: null\n  });\n\n  // ✅ track which panels were touched, so dragEnd persists once\n  const touchedPanelsRef = useRef(new Set());\n  const getWorkingContainers = useCallback(() => {\n    var _containersDraftRef$c;\n    return (_containersDraftRef$c = containersDraftRef.current) !== null && _containersDraftRef$c !== void 0 ? _containersDraftRef$c : state.containers;\n  }, [state.containers]);\n  const handleDragStart = useCallback(event => {\n    var _event$active$rect, _event$active$rect$cu;\n    dispatch(setDebugEventAction(pickEvent(event, \"start\")));\n    dispatch(setActiveIdAction(event.active.id));\n    const rect = (_event$active$rect = event.active.rect) === null || _event$active$rect === void 0 ? void 0 : (_event$active$rect$cu = _event$active$rect.current) === null || _event$active$rect$cu === void 0 ? void 0 : _event$active$rect$cu.initial;\n    if (rect) dispatch(setActiveSizeAction({\n      width: rect.width,\n      height: rect.height\n    }));\n    containersDraftRef.current = deepCloneContainers(state.containers);\n    lastOverRef.current = {\n      activeId: event.active.id,\n      overId: null,\n      overRole: null,\n      overContainerId: null\n    };\n    lastContainerMoveRef.current = {\n      fromPanelId: null,\n      toPanelId: null,\n      activeContainerId: null,\n      overChildId: null\n    };\n    touchedPanelsRef.current = new Set();\n    dispatch(softTickAction());\n  }, [dispatch, state.containers]);\n  const handleDragCancel = useCallback(() => {\n    dispatch(setDebugEventAction({\n      type: \"cancel\",\n      ts: Date.now()\n    }));\n    dispatch(setActiveIdAction(null));\n    dispatch(setActiveSizeAction(null));\n    containersDraftRef.current = null;\n    touchedPanelsRef.current = new Set();\n    dispatch(softTickAction());\n  }, [dispatch]);\n  const handleDragOver = useCallback(event => {\n    var _over$data$current$ro, _over$data2, _over$data2$current, _over$data$current$co, _over$data3, _over$data3$current, _active$data$current$, _active$data, _active$data$current;\n    const {\n      active,\n      over\n    } = event;\n    if (!over) return;\n    const nextOverRole = (_over$data$current$ro = (_over$data2 = over.data) === null || _over$data2 === void 0 ? void 0 : (_over$data2$current = _over$data2.current) === null || _over$data2$current === void 0 ? void 0 : _over$data2$current.role) !== null && _over$data$current$ro !== void 0 ? _over$data$current$ro : null;\n    const nextOverContainerId = (_over$data$current$co = (_over$data3 = over.data) === null || _over$data3 === void 0 ? void 0 : (_over$data3$current = _over$data3.current) === null || _over$data3$current === void 0 ? void 0 : _over$data3$current.containerId) !== null && _over$data$current$co !== void 0 ? _over$data$current$co : null;\n    const last = lastOverRef.current;\n    const sameOver = last.activeId === active.id && last.overId === over.id && last.overRole === nextOverRole && last.overContainerId === nextOverContainerId;\n    if (!sameOver) {\n      lastOverRef.current = {\n        activeId: active.id,\n        overId: over.id,\n        overRole: nextOverRole,\n        overContainerId: nextOverContainerId\n      };\n      dispatch(setDebugEventAction(pickEvent(event, \"over\")));\n    }\n    const activeRole = (_active$data$current$ = (_active$data = active.data) === null || _active$data === void 0 ? void 0 : (_active$data$current = _active$data.current) === null || _active$data$current === void 0 ? void 0 : _active$data$current.role) !== null && _active$data$current$ !== void 0 ? _active$data$current$ : null;\n    if (activeRole !== \"container\" && activeRole !== \"instance\") return;\n    const overInfo = getOverParent(over);\n    if (!overInfo) return;\n    if (!canDropInto(overInfo.parentRole, activeRole)) return;\n\n    // ======================================================\n    // INSTANCE -> CONTAINER (items)\n    // ======================================================\n    if (activeRole === \"instance\" && overInfo.parentRole === \"container\") {\n      var _over$data$current$ro2, _over$data4, _over$data4$current;\n      const draft = containersDraftRef.current;\n      if (!draft) return;\n      const instanceId = active.id;\n      const fromContainer = findContainerByInstanceId(instanceId, draft);\n      const toContainer = findContainerById(overInfo.parentId, draft);\n      if (!fromContainer || !toContainer) return;\n      const overRole = (_over$data$current$ro2 = (_over$data4 = over.data) === null || _over$data4 === void 0 ? void 0 : (_over$data4$current = _over$data4.current) === null || _over$data4$current === void 0 ? void 0 : _over$data4$current.role) !== null && _over$data$current$ro2 !== void 0 ? _over$data$current$ro2 : null;\n      const isOverInstance = overRole === \"instance\";\n      const overInstanceId = isOverInstance ? over.id : null;\n      const fromId = fromContainer.id;\n      const toId = toContainer.id;\n      const fromIndex = (fromContainer.items || []).indexOf(instanceId);\n      if (fromIndex === -1) return;\n\n      // compute toIndex using your existing behavior\n      let toIndex;\n      if (!overInstanceId) {\n        toIndex = (toContainer.items || []).length;\n      } else {\n        var _active$rect, _active$rect$current;\n        const idx = (toContainer.items || []).indexOf(overInstanceId);\n        toIndex = idx >= 0 ? idx : (toContainer.items || []).length;\n        const activeRect = (_active$rect = active.rect) === null || _active$rect === void 0 ? void 0 : (_active$rect$current = _active$rect.current) === null || _active$rect$current === void 0 ? void 0 : _active$rect$current.translated;\n        const overRect = over.rect;\n        const isBelow = activeRect && overRect ? activeRect.top > overRect.top + overRect.height / 2 : false;\n        toIndex = toIndex + (isBelow ? 1 : 0);\n      }\n      if (fromId === toId && !overInstanceId) return;\n      if (overInstanceId === instanceId) return;\n\n      // same container reorder\n      if (fromId === toId) {\n        if (toIndex === fromIndex) return;\n        const nextItems = arrayMove(fromContainer.items, fromIndex, toIndex);\n        containersDraftRef.current = draft.map(c => c.id === fromId ? {\n          ...c,\n          items: nextItems\n        } : c);\n        dispatch(softTickAction());\n        return;\n      }\n\n      // cross-container move via generic helper\n      const moved = moveChildAcrossParents({\n        childId: instanceId,\n        fromParent: fromContainer,\n        toParent: toContainer,\n        childKey: \"items\",\n        toIndex\n      });\n      if (!moved) return;\n      containersDraftRef.current = draft.map(c => {\n        if (c.id === moved.nextFromParent.id) return moved.nextFromParent;\n        if (c.id === moved.nextToParent.id) return moved.nextToParent;\n        return c;\n      });\n      dispatch(softTickAction());\n      return;\n    }\n\n    // ======================================================\n    // CONTAINER -> PANEL (containers)\n    // ======================================================\n    if (activeRole === \"container\" && overInfo.parentRole === \"panel\") {\n      var _active$data2, _active$data2$current, _overInfo$overChildId, _overInfo$overChildId2;\n      const activeContainerId = active.id;\n      const fromPanel = (_active$data2 = active.data) !== null && _active$data2 !== void 0 && (_active$data2$current = _active$data2.current) !== null && _active$data2$current !== void 0 && _active$data2$current.panelId ? findPanelById(active.data.current.panelId, state.panels || []) : findPanelByContainerId(activeContainerId, state.panels || []);\n      const toPanel = findPanelById(overInfo.parentId, state.panels || []);\n      if (!fromPanel || !toPanel) return;\n\n      // insert relative to hovered container tile, else append\n      let toIndex = null;\n      if (overInfo.overChildId) {\n        const idx = (toPanel.containers || []).indexOf(overInfo.overChildId);\n        if (idx >= 0) toIndex = idx;\n      }\n\n      // de-dupe spam\n      const lastM = lastContainerMoveRef.current;\n      if (lastM.fromPanelId === fromPanel.id && lastM.toPanelId === toPanel.id && lastM.activeContainerId === activeContainerId && lastM.overChildId === ((_overInfo$overChildId = overInfo.overChildId) !== null && _overInfo$overChildId !== void 0 ? _overInfo$overChildId : null)) {\n        return;\n      }\n      lastContainerMoveRef.current = {\n        fromPanelId: fromPanel.id,\n        toPanelId: toPanel.id,\n        activeContainerId,\n        overChildId: (_overInfo$overChildId2 = overInfo.overChildId) !== null && _overInfo$overChildId2 !== void 0 ? _overInfo$overChildId2 : null\n      };\n\n      // same-panel reorder: use arrayMove for nicer behavior\n      if (fromPanel.id === toPanel.id && overInfo.overChildId) {\n        const ids = fromPanel.containers || [];\n        const fromIndex = ids.indexOf(activeContainerId);\n        const hoverIndex = ids.indexOf(overInfo.overChildId);\n        if (fromIndex === -1 || hoverIndex === -1) return;\n        if (fromIndex === hoverIndex) return;\n        const nextIds = arrayMove(ids, fromIndex, hoverIndex);\n        dispatch(updatePanelAction({\n          ...fromPanel,\n          containers: nextIds\n        }));\n        touchedPanelsRef.current.add(fromPanel.id);\n        dispatch(softTickAction());\n        return;\n      }\n\n      // cross-panel move (or append into empty panel)\n      const moved = moveChildAcrossParents({\n        childId: activeContainerId,\n        fromParent: fromPanel,\n        toParent: toPanel,\n        childKey: \"containers\",\n        toIndex\n      });\n      if (!moved) return;\n      dispatch(updatePanelAction(moved.nextFromParent));\n      dispatch(updatePanelAction(moved.nextToParent));\n      touchedPanelsRef.current.add(moved.nextFromParent.id);\n      touchedPanelsRef.current.add(moved.nextToParent.id);\n      dispatch(softTickAction());\n      return;\n    }\n  }, [dispatch, state.panels]);\n  const handleDragEnd = useCallback(event => {\n    var _active$data$current$2, _active$data3, _active$data3$current;\n    dispatch(setDebugEventAction(pickEvent(event, \"end\")));\n    const {\n      active,\n      over\n    } = event;\n    const activeRole = (_active$data$current$2 = active === null || active === void 0 ? void 0 : (_active$data3 = active.data) === null || _active$data3 === void 0 ? void 0 : (_active$data3$current = _active$data3.current) === null || _active$data3$current === void 0 ? void 0 : _active$data3$current.role) !== null && _active$data$current$2 !== void 0 ? _active$data$current$2 : null;\n    dispatch(setActiveIdAction(null));\n    dispatch(setActiveSizeAction(null));\n\n    // ======================================================\n    // CONTAINER DROP END: persist touched panels\n    // ======================================================\n    if (activeRole === \"container\") {\n      if (!over) return;\n      const touched = Array.from(touchedPanelsRef.current || []);\n      for (const panelId of touched) {\n        const panel = (state.panels || []).find(p => p.id === panelId);\n        if (panel) socket === null || socket === void 0 ? void 0 : socket.emit(\"update_panel\", {\n          panel,\n          gridId: panel.gridId\n        });\n      }\n      touchedPanelsRef.current = new Set();\n      return;\n    }\n\n    // ======================================================\n    // INSTANCE DROP END: commit + persist diffs\n    // ======================================================\n    if (!over) {\n      containersDraftRef.current = null;\n      dispatch(softTickAction());\n      return;\n    }\n    const draft = containersDraftRef.current;\n    if (draft) {\n      dispatch(setContainersAction(draft));\n      const prev = state.containers;\n      for (const nextC of draft) {\n        var _prevC$items;\n        const prevC = (prev || []).find(c => c.id === nextC.id);\n        const prevItems = (_prevC$items = prevC === null || prevC === void 0 ? void 0 : prevC.items) !== null && _prevC$items !== void 0 ? _prevC$items : [];\n        if (!itemsEqual(prevItems, nextC.items)) {\n          socket === null || socket === void 0 ? void 0 : socket.emit(\"update_container_items\", {\n            containerId: nextC.id,\n            items: nextC.items\n          });\n        }\n      }\n      containersDraftRef.current = null;\n      dispatch(softTickAction());\n    }\n  }, [dispatch, socket, state.containers, state.panels]);\n  return useMemo(() => ({\n    handleDragStart,\n    handleDragOver,\n    handleDragEnd,\n    handleDragCancel,\n    containersDraftRef,\n    getWorkingContainers\n  }), [handleDragStart, handleDragOver, handleDragEnd, handleDragCancel, getWorkingContainers]);\n}\n_s(useDndReorderCoordinator, \"nJv4rQh6IK8yk0c2COu12diMCM8=\");","map":{"version":3,"names":["useCallback","useMemo","useRef","createContainerAction","createInstanceInContainerAction","setActiveIdAction","setActiveSizeAction","setContainersAction","setDebugEventAction","softTickAction","updatePanelAction","ACCEPTS","panel","container","uid","Date","now","toString","Math","random","slice","arrayMove","arr","from","to","copy","item","splice","deepCloneContainers","containers","map","c","items","pickEvent","event","type","_a$data","_o$data","_activeData$role","_activeData$container","_activeData$panelId","_overData$role","_overData$containerId","_overData$panelId","a","active","o","over","activeData","data","current","overData","ts","id","role","containerId","panelId","itemsEqual","b","length","i","removeOne","list","idx","indexOf","next","insertAt","index","clamped","max","min","moveChildAcrossParents","childId","fromParent","toParent","childKey","toIndex","fromList","toList","fromNext","fromIndex","insertIndex","toNext","nextFromParent","nextToParent","findPanelById","panels","find","p","findPanelByContainerId","includes","findContainerByInstanceId","instanceId","findContainerById","canDropInto","parentRole","childRole","getOverParent","_over$data","d","startsWith","parentId","overChildId","useDndReorderCoordinator","state","dispatch","socket","_s","containersDraftRef","lastOverRef","activeId","overId","overRole","overContainerId","lastContainerMoveRef","fromPanelId","toPanelId","activeContainerId","touchedPanelsRef","Set","getWorkingContainers","_containersDraftRef$c","handleDragStart","_event$active$rect","_event$active$rect$cu","rect","initial","width","height","handleDragCancel","handleDragOver","_over$data$current$ro","_over$data2","_over$data2$current","_over$data$current$co","_over$data3","_over$data3$current","_active$data$current$","_active$data","_active$data$current","nextOverRole","nextOverContainerId","last","sameOver","activeRole","overInfo","_over$data$current$ro2","_over$data4","_over$data4$current","draft","fromContainer","toContainer","isOverInstance","overInstanceId","fromId","toId","_active$rect","_active$rect$current","activeRect","translated","overRect","isBelow","top","nextItems","moved","_active$data2","_active$data2$current","_overInfo$overChildId","_overInfo$overChildId2","fromPanel","toPanel","lastM","ids","hoverIndex","nextIds","add","handleDragEnd","_active$data$current$2","_active$data3","_active$data3$current","touched","Array","emit","gridId","prev","nextC","_prevC$items","prevC","prevItems"],"sources":["/home/joshpoms/dndtest2/client/src/helpers/useDndReorderCoordinator.js"],"sourcesContent":["// dnd/useDndReorderCoordinator.js\nimport { useCallback, useMemo, useRef } from \"react\";\nimport {\n  createContainerAction,\n  createInstanceInContainerAction,\n  setActiveIdAction,\n  setActiveSizeAction,\n  setContainersAction,\n  setDebugEventAction,\n  softTickAction,\n  updatePanelAction,\n} from \"../state/actions\";\n\n// ✅ Schema: who accepts what\nconst ACCEPTS = {\n  panel: [\"container\"],\n  container: [\"instance\"],\n};\n\n// ---------- utilities ----------\nfunction uid() {\n  return Date.now().toString(36) + Math.random().toString(36).slice(2, 10);\n}\n\nfunction arrayMove(arr, from, to) {\n  const copy = [...arr];\n  const [item] = copy.splice(from, 1);\n  copy.splice(to, 0, item);\n  return copy;\n}\n\nfunction deepCloneContainers(containers) {\n  return (containers || []).map((c) => ({ ...c, items: [...(c.items || [])] }));\n}\n\n// ✅ Safe event snapshot for debug UI (no circular refs)\nfunction pickEvent(event, type) {\n  const a = event?.active;\n  const o = event?.over;\n\n  const activeData = a?.data?.current || null;\n  const overData = o?.data?.current || null;\n\n  return {\n    type,\n    ts: Date.now(),\n    active: a\n      ? {\n          id: a.id,\n          role: activeData?.role ?? null,\n          containerId: activeData?.containerId ?? null,\n          panelId: activeData?.panelId ?? null,\n          data: activeData,\n        }\n      : null,\n    over: o\n      ? {\n          id: o.id,\n          role: overData?.role ?? null,\n          containerId: overData?.containerId ?? null,\n          panelId: overData?.panelId ?? null,\n          data: overData,\n        }\n      : null,\n  };\n}\n\nfunction itemsEqual(a = [], b = []) {\n  if (a === b) return true;\n  if (!a || !b) return false;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n  return true;\n}\n\n// ---------- generic list move helpers ----------\nfunction removeOne(list = [], id) {\n  const idx = list.indexOf(id);\n  if (idx === -1) return { list, idx: -1 };\n  const next = [...list];\n  next.splice(idx, 1);\n  return { list: next, idx };\n}\n\nfunction insertAt(list = [], id, index) {\n  const next = [...list];\n  const clamped = Math.max(0, Math.min(next.length, index));\n  next.splice(clamped, 0, id);\n  return next;\n}\n\nfunction moveChildAcrossParents({ childId, fromParent, toParent, childKey, toIndex = null }) {\n  if (!fromParent || !toParent) return null;\n\n  const fromList = fromParent[childKey] || [];\n  const toList = toParent[childKey] || [];\n\n  const { list: fromNext, idx: fromIndex } = removeOne(fromList, childId);\n  if (fromIndex === -1) return null;\n\n  const insertIndex = toIndex == null ? toList.length : toIndex;\n  const toNext = insertAt(toList, childId, insertIndex);\n\n  return {\n    nextFromParent: { ...fromParent, [childKey]: fromNext },\n    nextToParent: { ...toParent, [childKey]: toNext },\n    fromIndex,\n  };\n}\n\n// ---------- parent finders ----------\nfunction findPanelById(panelId, panels = []) {\n  return (panels || []).find((p) => p.id === panelId) || null;\n}\n\nfunction findPanelByContainerId(containerId, panels = []) {\n  return (panels || []).find((p) => (p.containers || []).includes(containerId)) || null;\n}\n\nfunction findContainerByInstanceId(instanceId, list = []) {\n  return (list || []).find((c) => (c.items || []).includes(instanceId)) || null;\n}\n\nfunction findContainerById(containerId, list = []) {\n  return (list || []).find((c) => c.id === containerId) || null;\n}\n\nfunction canDropInto(parentRole, childRole) {\n  return (ACCEPTS[parentRole] || []).includes(childRole);\n}\n\n/**\n * Normalizes over into:\n *   { parentRole: \"panel\"|\"container\", parentId, overChildId? }\n */\nfunction getOverParent(over) {\n  if (!over) return null;\n  const d = over.data?.current || {};\n\n  // ✅ Container list/top/bottom => parent is container\n  if (d?.containerId && typeof d?.role === \"string\" && d.role.startsWith(\"container:\")) {\n    return { parentRole: \"container\", parentId: d.containerId };\n  }\n\n  // ✅ Hovering an instance => parent is container\n  if (d?.role === \"instance\" && d?.containerId) {\n    return { parentRole: \"container\", parentId: d.containerId, overChildId: over.id };\n  }\n\n  // ✅ Panel dropzone => parent is panel\n  if (d?.role === \"panel:drop\" && d?.panelId) {\n    return { parentRole: \"panel\", parentId: d.panelId };\n  }\n\n  // ✅ Hovering a container tile => parent is panel (insert relative to that container)\n  if (d?.role === \"container\" && d?.panelId) {\n    return { parentRole: \"panel\", parentId: d.panelId, overChildId: over.id };\n  }\n\n  return null;\n}\n\n// ---------- hook ----------\nexport function useDndReorderCoordinator({ state, dispatch, socket }) {\n  // instance soft-sort draft ref (kept out of reducer on purpose)\n  const containersDraftRef = useRef(null);\n\n  const lastOverRef = useRef({\n    activeId: null,\n    overId: null,\n    overRole: null,\n    overContainerId: null,\n  });\n\n  // ✅ de-dupe spam for panel container moves\n  const lastContainerMoveRef = useRef({\n    fromPanelId: null,\n    toPanelId: null,\n    activeContainerId: null,\n    overChildId: null,\n  });\n\n  // ✅ track which panels were touched, so dragEnd persists once\n  const touchedPanelsRef = useRef(new Set());\n\n  const getWorkingContainers = useCallback(() => {\n    return containersDraftRef.current ?? state.containers;\n  }, [state.containers]);\n\n  const handleDragStart = useCallback(\n    (event) => {\n      dispatch(setDebugEventAction(pickEvent(event, \"start\")));\n      dispatch(setActiveIdAction(event.active.id));\n\n      const rect = event.active.rect?.current?.initial;\n      if (rect) dispatch(setActiveSizeAction({ width: rect.width, height: rect.height }));\n\n      containersDraftRef.current = deepCloneContainers(state.containers);\n\n      lastOverRef.current = {\n        activeId: event.active.id,\n        overId: null,\n        overRole: null,\n        overContainerId: null,\n      };\n\n      lastContainerMoveRef.current = {\n        fromPanelId: null,\n        toPanelId: null,\n        activeContainerId: null,\n        overChildId: null,\n      };\n\n      touchedPanelsRef.current = new Set();\n\n      dispatch(softTickAction());\n    },\n    [dispatch, state.containers]\n  );\n\n  const handleDragCancel = useCallback(() => {\n    dispatch(setDebugEventAction({ type: \"cancel\", ts: Date.now() }));\n    dispatch(setActiveIdAction(null));\n    dispatch(setActiveSizeAction(null));\n\n    containersDraftRef.current = null;\n    touchedPanelsRef.current = new Set();\n\n    dispatch(softTickAction());\n  }, [dispatch]);\n\n  const handleDragOver = useCallback(\n    (event) => {\n      const { active, over } = event;\n      if (!over) return;\n\n      const nextOverRole = over.data?.current?.role ?? null;\n      const nextOverContainerId = over.data?.current?.containerId ?? null;\n\n      const last = lastOverRef.current;\n      const sameOver =\n        last.activeId === active.id &&\n        last.overId === over.id &&\n        last.overRole === nextOverRole &&\n        last.overContainerId === nextOverContainerId;\n\n      if (!sameOver) {\n        lastOverRef.current = {\n          activeId: active.id,\n          overId: over.id,\n          overRole: nextOverRole,\n          overContainerId: nextOverContainerId,\n        };\n        dispatch(setDebugEventAction(pickEvent(event, \"over\")));\n      }\n\n      const activeRole = active.data?.current?.role ?? null;\n      if (activeRole !== \"container\" && activeRole !== \"instance\") return;\n\n      const overInfo = getOverParent(over);\n      if (!overInfo) return;\n\n      if (!canDropInto(overInfo.parentRole, activeRole)) return;\n\n      // ======================================================\n      // INSTANCE -> CONTAINER (items)\n      // ======================================================\n      if (activeRole === \"instance\" && overInfo.parentRole === \"container\") {\n        const draft = containersDraftRef.current;\n        if (!draft) return;\n\n        const instanceId = active.id;\n        const fromContainer = findContainerByInstanceId(instanceId, draft);\n        const toContainer = findContainerById(overInfo.parentId, draft);\n        if (!fromContainer || !toContainer) return;\n\n        const overRole = over.data?.current?.role ?? null;\n        const isOverInstance = overRole === \"instance\";\n        const overInstanceId = isOverInstance ? over.id : null;\n\n        const fromId = fromContainer.id;\n        const toId = toContainer.id;\n\n        const fromIndex = (fromContainer.items || []).indexOf(instanceId);\n        if (fromIndex === -1) return;\n\n        // compute toIndex using your existing behavior\n        let toIndex;\n        if (!overInstanceId) {\n          toIndex = (toContainer.items || []).length;\n        } else {\n          const idx = (toContainer.items || []).indexOf(overInstanceId);\n          toIndex = idx >= 0 ? idx : (toContainer.items || []).length;\n\n          const activeRect = active.rect?.current?.translated;\n          const overRect = over.rect;\n          const isBelow =\n            activeRect && overRect\n              ? activeRect.top > overRect.top + overRect.height / 2\n              : false;\n\n          toIndex = toIndex + (isBelow ? 1 : 0);\n        }\n\n        if (fromId === toId && !overInstanceId) return;\n        if (overInstanceId === instanceId) return;\n\n        // same container reorder\n        if (fromId === toId) {\n          if (toIndex === fromIndex) return;\n          const nextItems = arrayMove(fromContainer.items, fromIndex, toIndex);\n          containersDraftRef.current = draft.map((c) =>\n            c.id === fromId ? { ...c, items: nextItems } : c\n          );\n          dispatch(softTickAction());\n          return;\n        }\n\n        // cross-container move via generic helper\n        const moved = moveChildAcrossParents({\n          childId: instanceId,\n          fromParent: fromContainer,\n          toParent: toContainer,\n          childKey: \"items\",\n          toIndex,\n        });\n        if (!moved) return;\n\n        containersDraftRef.current = draft.map((c) => {\n          if (c.id === moved.nextFromParent.id) return moved.nextFromParent;\n          if (c.id === moved.nextToParent.id) return moved.nextToParent;\n          return c;\n        });\n\n        dispatch(softTickAction());\n        return;\n      }\n\n      // ======================================================\n      // CONTAINER -> PANEL (containers)\n      // ======================================================\n      if (activeRole === \"container\" && overInfo.parentRole === \"panel\") {\n        const activeContainerId = active.id;\n\n        const fromPanel =\n          active.data?.current?.panelId\n            ? findPanelById(active.data.current.panelId, state.panels || [])\n            : findPanelByContainerId(activeContainerId, state.panels || []);\n\n        const toPanel = findPanelById(overInfo.parentId, state.panels || []);\n\n        if (!fromPanel || !toPanel) return;\n\n        // insert relative to hovered container tile, else append\n        let toIndex = null;\n        if (overInfo.overChildId) {\n          const idx = (toPanel.containers || []).indexOf(overInfo.overChildId);\n          if (idx >= 0) toIndex = idx;\n        }\n\n        // de-dupe spam\n        const lastM = lastContainerMoveRef.current;\n        if (\n          lastM.fromPanelId === fromPanel.id &&\n          lastM.toPanelId === toPanel.id &&\n          lastM.activeContainerId === activeContainerId &&\n          lastM.overChildId === (overInfo.overChildId ?? null)\n        ) {\n          return;\n        }\n        lastContainerMoveRef.current = {\n          fromPanelId: fromPanel.id,\n          toPanelId: toPanel.id,\n          activeContainerId,\n          overChildId: overInfo.overChildId ?? null,\n        };\n\n        // same-panel reorder: use arrayMove for nicer behavior\n        if (fromPanel.id === toPanel.id && overInfo.overChildId) {\n          const ids = fromPanel.containers || [];\n          const fromIndex = ids.indexOf(activeContainerId);\n          const hoverIndex = ids.indexOf(overInfo.overChildId);\n          if (fromIndex === -1 || hoverIndex === -1) return;\n          if (fromIndex === hoverIndex) return;\n\n          const nextIds = arrayMove(ids, fromIndex, hoverIndex);\n          dispatch(updatePanelAction({ ...fromPanel, containers: nextIds }));\n          touchedPanelsRef.current.add(fromPanel.id);\n          dispatch(softTickAction());\n          return;\n        }\n\n        // cross-panel move (or append into empty panel)\n        const moved = moveChildAcrossParents({\n          childId: activeContainerId,\n          fromParent: fromPanel,\n          toParent: toPanel,\n          childKey: \"containers\",\n          toIndex,\n        });\n        if (!moved) return;\n\n        dispatch(updatePanelAction(moved.nextFromParent));\n        dispatch(updatePanelAction(moved.nextToParent));\n\n        touchedPanelsRef.current.add(moved.nextFromParent.id);\n        touchedPanelsRef.current.add(moved.nextToParent.id);\n\n        dispatch(softTickAction());\n        return;\n      }\n    },\n    [dispatch, state.panels]\n  );\n\n  const handleDragEnd = useCallback(\n    (event) => {\n      dispatch(setDebugEventAction(pickEvent(event, \"end\")));\n\n      const { active, over } = event;\n      const activeRole = active?.data?.current?.role ?? null;\n\n      dispatch(setActiveIdAction(null));\n      dispatch(setActiveSizeAction(null));\n\n      // ======================================================\n      // CONTAINER DROP END: persist touched panels\n      // ======================================================\n      if (activeRole === \"container\") {\n        if (!over) return;\n\n        const touched = Array.from(touchedPanelsRef.current || []);\n        for (const panelId of touched) {\n          const panel = (state.panels || []).find((p) => p.id === panelId);\n          if (panel) socket?.emit(\"update_panel\", { panel, gridId: panel.gridId });\n        }\n\n        touchedPanelsRef.current = new Set();\n        return;\n      }\n\n      // ======================================================\n      // INSTANCE DROP END: commit + persist diffs\n      // ======================================================\n      if (!over) {\n        containersDraftRef.current = null;\n        dispatch(softTickAction());\n        return;\n      }\n\n      const draft = containersDraftRef.current;\n\n      if (draft) {\n        dispatch(setContainersAction(draft));\n\n        const prev = state.containers;\n        for (const nextC of draft) {\n          const prevC = (prev || []).find((c) => c.id === nextC.id);\n          const prevItems = prevC?.items ?? [];\n          if (!itemsEqual(prevItems, nextC.items)) {\n            socket?.emit(\"update_container_items\", {\n              containerId: nextC.id,\n              items: nextC.items,\n            });\n          }\n        }\n\n        containersDraftRef.current = null;\n        dispatch(softTickAction());\n      }\n    },\n    [dispatch, socket, state.containers, state.panels]\n  );\n\n  return useMemo(\n    () => ({\n      handleDragStart,\n      handleDragOver,\n      handleDragEnd,\n      handleDragCancel,\n      containersDraftRef,\n      getWorkingContainers,\n    }),\n    [handleDragStart, handleDragOver, handleDragEnd, handleDragCancel, getWorkingContainers]\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}