{"ast":null,"code":"import { isServerEnvironment } from './is-server-environment';\nconst UNDERSCORE_UNICODE = 95;\n/**\n * This length includes the underscore,\n * e.g. `\"_1s4A\"` would be a valid atomic group hash.\n */\nconst ATOMIC_GROUP_LENGTH = 5;\n/**\n * Memoize the result of ac so if it is called with the same args, it returns immediately.\n * Also, to prevent useless React rerenders\n */\nconst cache = new Map();\n/**\n * `ac` returns an instance of AtomicGroups. The instance holds the knowledge of Atomic Group so we can chain `ac`.\n * e.g. <div className={ax([ax(['_aaaa_b']), '_aaaa_c'])} />\n */\nclass AtomicGroups {\n  constructor(values) {\n    // An object stores the relation between Atomic group and actual class name\n    // e.g. { \"aaaa\": \"a\" } `aaaa` is the Atomic group and `a` is the actual class name\n    this.values = values;\n  }\n  toString() {\n    let str = '';\n    for (const [, value] of this.values) {\n      str += value + ' ';\n    }\n    return str.slice(0, -1);\n  }\n}\n/**\n * Joins classes together and ensures atomic declarations of a single group exist.\n * Atomic declarations take the form of `_{group}{value}` (always prefixed with an underscore),\n * where both `group` and `value` are hashes **four characters long**.\n * Class names can be of any length,\n * this function can take both atomic declarations and class names.\n *\n * Input:\n *\n * ```\n * ax(['_aaaabbbb', '_aaaacccc'])\n * ```\n *\n * Output:\n *\n * ```\n * '_aaaacccc'\n * ```\n *\n * @param classes\n */\nexport function ac(classNames) {\n  // short circuit if there's no class names.\n  if (classNames.length <= 1 && !classNames[0]) return undefined;\n  const atomicGroups = new Map();\n  for (let i = 0; i < classNames.length; i++) {\n    const cls = classNames[i];\n    if (!cls) {\n      continue;\n    }\n    if (typeof cls === 'string') {\n      const groups = cls.split(' ');\n      for (let x = 0; x < groups.length; x++) {\n        const atomic = groups[x];\n        const isAtomic = atomic.charCodeAt(0) === UNDERSCORE_UNICODE;\n        const isCompressed = isAtomic && atomic.charCodeAt(5) === UNDERSCORE_UNICODE;\n        const atomicGroupName = isAtomic ? atomic.slice(0, ATOMIC_GROUP_LENGTH) : atomic;\n        atomicGroups.set(atomicGroupName, isCompressed ? atomic.slice(ATOMIC_GROUP_LENGTH + 1) : atomic);\n      }\n    } else {\n      // if cls is an instance of AtomicGroups, transfer its values to `atomicGroups`\n      for (const [key, value] of cls.values) {\n        atomicGroups.set(key, value);\n      }\n    }\n  }\n  return new AtomicGroups(atomicGroups);\n}\nexport function memoizedAc(classNames) {\n  // short circuit if there's no class names.\n  if (classNames.length <= 1 && !classNames[0]) return undefined;\n  // build the cacheKey based on the function argument\n  // e.g. if the argument is [\"_aaaabbbb\", \"_aaaa_a\", \"some-class-name\"],\n  // then the cacheKey is \"_aaaabbbb _aaaa_a some-class-name\"\n  let cacheKey = '';\n  for (let i = 0; i < classNames.length; i += 1) {\n    const current = classNames[i];\n    // continue if current is undefined, false, or \"\"\n    if (!current) continue;\n    cacheKey += current + ' ';\n  }\n  cacheKey = cacheKey.slice(0, -1);\n  if (cache.has(cacheKey)) return cache.get(cacheKey);\n  const result = ac(classNames);\n  cache.set(cacheKey, result);\n  return result;\n}\n// Memoization is primarily used to prevent React from unncessary re-rendering.\n// Use unmemoizedAc on server-side because We don't need to worry about re-rendering on server-side.\nexport default isServerEnvironment() ? ac : memoizedAc;\n/**\n * Provide an opportunity to clear the cache to prevent memory leak.\n */\nexport function clearCache() {\n  cache.clear();\n}\n/**\n * Expose cache\n */\nexport function getCache() {\n  return cache;\n}","map":{"version":3,"names":["isServerEnvironment","UNDERSCORE_UNICODE","ATOMIC_GROUP_LENGTH","cache","Map","AtomicGroups","constructor","values","toString","str","value","slice","ac","classNames","length","undefined","atomicGroups","i","cls","groups","split","x","atomic","isAtomic","charCodeAt","isCompressed","atomicGroupName","set","key","memoizedAc","cacheKey","current","has","get","result","clearCache","clear","getCache"],"sources":["/data/data/com.termux/files/home/dndkittest2/client/node_modules/@compiled/react/src/runtime/ac.ts"],"sourcesContent":["import { isServerEnvironment } from './is-server-environment';\n\nconst UNDERSCORE_UNICODE = 95;\n\n/**\n * This length includes the underscore,\n * e.g. `\"_1s4A\"` would be a valid atomic group hash.\n */\nconst ATOMIC_GROUP_LENGTH = 5;\n\n/**\n * Memoize the result of ac so if it is called with the same args, it returns immediately.\n * Also, to prevent useless React rerenders\n */\nconst cache = new Map();\n\n/**\n * `ac` returns an instance of AtomicGroups. The instance holds the knowledge of Atomic Group so we can chain `ac`.\n * e.g. <div className={ax([ax(['_aaaa_b']), '_aaaa_c'])} />\n */\nclass AtomicGroups {\n  values: Map<string, string>;\n  constructor(values: Map<string, string>) {\n    // An object stores the relation between Atomic group and actual class name\n    // e.g. { \"aaaa\": \"a\" } `aaaa` is the Atomic group and `a` is the actual class name\n    this.values = values;\n  }\n  toString() {\n    let str = '';\n\n    for (const [, value] of this.values) {\n      str += value + ' ';\n    }\n\n    return str.slice(0, -1);\n  }\n}\n\n/**\n * Joins classes together and ensures atomic declarations of a single group exist.\n * Atomic declarations take the form of `_{group}{value}` (always prefixed with an underscore),\n * where both `group` and `value` are hashes **four characters long**.\n * Class names can be of any length,\n * this function can take both atomic declarations and class names.\n *\n * Input:\n *\n * ```\n * ax(['_aaaabbbb', '_aaaacccc'])\n * ```\n *\n * Output:\n *\n * ```\n * '_aaaacccc'\n * ```\n *\n * @param classes\n */\nexport function ac(\n  classNames: (AtomicGroups | string | null | undefined | false)[]\n): AtomicGroups | undefined {\n  // short circuit if there's no class names.\n  if (classNames.length <= 1 && !classNames[0]) return undefined;\n\n  const atomicGroups: Map<string, string> = new Map();\n\n  for (let i = 0; i < classNames.length; i++) {\n    const cls = classNames[i];\n    if (!cls) {\n      continue;\n    }\n\n    if (typeof cls === 'string') {\n      const groups = cls.split(' ');\n\n      for (let x = 0; x < groups.length; x++) {\n        const atomic = groups[x];\n        const isAtomic = atomic.charCodeAt(0) === UNDERSCORE_UNICODE;\n        const isCompressed = isAtomic && atomic.charCodeAt(5) === UNDERSCORE_UNICODE;\n\n        const atomicGroupName = isAtomic ? atomic.slice(0, ATOMIC_GROUP_LENGTH) : atomic;\n        atomicGroups.set(\n          atomicGroupName,\n          isCompressed ? atomic.slice(ATOMIC_GROUP_LENGTH + 1) : atomic\n        );\n      }\n    } else {\n      // if cls is an instance of AtomicGroups, transfer its values to `atomicGroups`\n      for (const [key, value] of cls.values) {\n        atomicGroups.set(key, value);\n      }\n    }\n  }\n\n  return new AtomicGroups(atomicGroups);\n}\n\nexport function memoizedAc(\n  classNames: (AtomicGroups | string | undefined | false)[]\n): AtomicGroups | undefined {\n  // short circuit if there's no class names.\n  if (classNames.length <= 1 && !classNames[0]) return undefined;\n\n  // build the cacheKey based on the function argument\n  // e.g. if the argument is [\"_aaaabbbb\", \"_aaaa_a\", \"some-class-name\"],\n  // then the cacheKey is \"_aaaabbbb _aaaa_a some-class-name\"\n  let cacheKey = '';\n  for (let i = 0; i < classNames.length; i += 1) {\n    const current = classNames[i];\n    // continue if current is undefined, false, or \"\"\n    if (!current) continue;\n    cacheKey += current + ' ';\n  }\n\n  cacheKey = cacheKey.slice(0, -1);\n\n  if (cache.has(cacheKey)) return cache.get(cacheKey);\n\n  const result = ac(classNames);\n\n  cache.set(cacheKey, result);\n\n  return result;\n}\n\n// Memoization is primarily used to prevent React from unncessary re-rendering.\n// Use unmemoizedAc on server-side because We don't need to worry about re-rendering on server-side.\nexport default isServerEnvironment() ? ac : memoizedAc;\n\n/**\n * Provide an opportunity to clear the cache to prevent memory leak.\n */\nexport function clearCache(): void {\n  cache.clear();\n}\n\n/**\n * Expose cache\n */\nexport function getCache(): typeof cache {\n  return cache;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}