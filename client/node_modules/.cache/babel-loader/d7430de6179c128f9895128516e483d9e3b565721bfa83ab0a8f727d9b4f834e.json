{"ast":null,"code":"var _s = $RefreshSig$();\n// dnd/useDndReorderCoordinator.js\nimport { useCallback, useMemo, useRef, useEffect } from \"react\";\nimport { createContainerAction, createInstanceInContainerAction, setActiveIdAction, setActiveSizeAction, setContainersAction, setDebugEventAction, softTickAction, updatePanelAction } from \"../state/actions\";\n\n// ✅ Schema: who accepts what\nconst ACCEPTS = {\n  panel: [\"container\"],\n  container: [\"instance\"]\n};\n\n// ---------- utilities ----------\nfunction uid() {\n  return Date.now().toString(36) + Math.random().toString(36).slice(2, 10);\n}\nfunction arrayMove(arr, from, to) {\n  const copy = [...arr];\n  const [item] = copy.splice(from, 1);\n  copy.splice(to, 0, item);\n  return copy;\n}\nfunction deepCloneContainers(containers) {\n  return (containers || []).map(c => ({\n    ...c,\n    items: [...(c.items || [])]\n  }));\n}\n\n// ✅ Safe event snapshot for debug UI (no circular refs)\nfunction pickEvent(event, type) {\n  var _a$data, _o$data, _activeData$role, _activeData$container, _activeData$panelId, _overData$role, _overData$containerId, _overData$panelId;\n  const a = event === null || event === void 0 ? void 0 : event.active;\n  const o = event === null || event === void 0 ? void 0 : event.over;\n  const activeData = (a === null || a === void 0 ? void 0 : (_a$data = a.data) === null || _a$data === void 0 ? void 0 : _a$data.current) || null;\n  const overData = (o === null || o === void 0 ? void 0 : (_o$data = o.data) === null || _o$data === void 0 ? void 0 : _o$data.current) || null;\n  return {\n    type,\n    ts: Date.now(),\n    active: a ? {\n      id: a.id,\n      role: (_activeData$role = activeData === null || activeData === void 0 ? void 0 : activeData.role) !== null && _activeData$role !== void 0 ? _activeData$role : null,\n      containerId: (_activeData$container = activeData === null || activeData === void 0 ? void 0 : activeData.containerId) !== null && _activeData$container !== void 0 ? _activeData$container : null,\n      panelId: (_activeData$panelId = activeData === null || activeData === void 0 ? void 0 : activeData.panelId) !== null && _activeData$panelId !== void 0 ? _activeData$panelId : null,\n      data: activeData\n    } : null,\n    over: o ? {\n      id: o.id,\n      role: (_overData$role = overData === null || overData === void 0 ? void 0 : overData.role) !== null && _overData$role !== void 0 ? _overData$role : null,\n      containerId: (_overData$containerId = overData === null || overData === void 0 ? void 0 : overData.containerId) !== null && _overData$containerId !== void 0 ? _overData$containerId : null,\n      panelId: (_overData$panelId = overData === null || overData === void 0 ? void 0 : overData.panelId) !== null && _overData$panelId !== void 0 ? _overData$panelId : null,\n      data: overData\n    } : null\n  };\n}\nfunction itemsEqual(a = [], b = []) {\n  if (a === b) return true;\n  if (!a || !b) return false;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n  return true;\n}\n\n// ---------- generic list move helpers ----------\nfunction removeOne(list = [], id) {\n  const idx = list.indexOf(id);\n  if (idx === -1) return {\n    list,\n    idx: -1\n  };\n  const next = [...list];\n  next.splice(idx, 1);\n  return {\n    list: next,\n    idx\n  };\n}\nfunction insertAt(list = [], id, index) {\n  const next = [...list];\n  const clamped = Math.max(0, Math.min(next.length, index));\n  next.splice(clamped, 0, id);\n  return next;\n}\nfunction moveChildAcrossParents({\n  childId,\n  fromParent,\n  toParent,\n  childKey,\n  toIndex = null\n}) {\n  if (!fromParent || !toParent) return null;\n  const rawFrom = fromParent[childKey] || [];\n  const rawTo = toParent[childKey] || [];\n  const fromHad = rawFrom.includes(childId);\n\n  // ✅ remove from BOTH sides first to prevent duplicates during dragOver spam\n  const fromList = rawFrom.filter(x => x !== childId);\n  const toList = rawTo.filter(x => x !== childId);\n\n  // If it's a true cross-parent move, and the source didn't actually have it, bail\n  if (fromParent.id !== toParent.id && !fromHad) return null;\n  const insertIndex = toIndex == null ? toList.length : toIndex;\n  const toNext = insertAt(toList, childId, insertIndex);\n  return {\n    nextFromParent: {\n      ...fromParent,\n      [childKey]: fromList\n    },\n    nextToParent: {\n      ...toParent,\n      [childKey]: toNext\n    }\n  };\n}\n\n// ---------- parent finders ----------\nfunction findPanelById(panelId, panels = []) {\n  return (panels || []).find(p => p.id === panelId) || null;\n}\nfunction findPanelByContainerId(containerId, panels = []) {\n  return (panels || []).find(p => (p.containers || []).includes(containerId)) || null;\n}\nfunction findContainerByInstanceId(instanceId, list = []) {\n  return (list || []).find(c => (c.items || []).includes(instanceId)) || null;\n}\nfunction findContainerById(containerId, list = []) {\n  return (list || []).find(c => c.id === containerId) || null;\n}\nfunction canDropInto(parentRole, childRole) {\n  return (ACCEPTS[parentRole] || []).includes(childRole);\n}\n\n/**\n * Normalizes over into:\n *   { parentRole: \"panel\"|\"container\", parentId, overChildId? }\n */\nfunction getOverParent(over) {\n  var _over$data;\n  if (!over) return null;\n  const d = ((_over$data = over.data) === null || _over$data === void 0 ? void 0 : _over$data.current) || {};\n\n  // ✅ Container list/top/bottom => parent is container\n  if (d !== null && d !== void 0 && d.containerId && typeof (d === null || d === void 0 ? void 0 : d.role) === \"string\" && d.role.startsWith(\"container:\")) {\n    return {\n      parentRole: \"container\",\n      parentId: d.containerId\n    };\n  }\n\n  // ✅ Hovering an instance => parent is container\n  if ((d === null || d === void 0 ? void 0 : d.role) === \"instance\" && d !== null && d !== void 0 && d.containerId) {\n    return {\n      parentRole: \"container\",\n      parentId: d.containerId,\n      overChildId: over.id\n    };\n  }\n\n  // ✅ Panel dropzone => parent is panel\n  if ((d === null || d === void 0 ? void 0 : d.role) === \"panel:drop\" && d !== null && d !== void 0 && d.panelId) {\n    return {\n      parentRole: \"panel\",\n      parentId: d.panelId\n    };\n  }\n\n  // ✅ Hovering a container tile => parent is panel (insert relative to that container)\n  if ((d === null || d === void 0 ? void 0 : d.role) === \"container\" && d !== null && d !== void 0 && d.panelId) {\n    return {\n      parentRole: \"panel\",\n      parentId: d.panelId,\n      overChildId: over.id\n    };\n  }\n  return null;\n}\n\n// ---------- hook ----------\nexport function useDndReorderCoordinator({\n  state,\n  dispatch,\n  socket\n}) {\n  _s();\n  // instance soft-sort draft ref (kept out of reducer on purpose)\n  const containersDraftRef = useRef(null);\n  const lastOverRef = useRef({\n    activeId: null,\n    overId: null,\n    overRole: null,\n    overContainerId: null\n  });\n\n  // ✅ de-dupe spam for panel container moves\n  const lastContainerMoveRef = useRef({\n    fromPanelId: null,\n    toPanelId: null,\n    activeContainerId: null,\n    overChildId: null\n  });\n\n  // ✅ track which panels were touched, so dragEnd persists once\n  const touchedPanelsRef = useRef(new Set());\n  const getWorkingContainers = useCallback(() => {\n    var _containersDraftRef$c;\n    return (_containersDraftRef$c = containersDraftRef.current) !== null && _containersDraftRef$c !== void 0 ? _containersDraftRef$c : state.containers;\n  }, [state.containers]);\n  const handleDragStart = useCallback(event => {\n    var _event$active$rect, _event$active$rect$cu;\n    dispatch(setDebugEventAction(pickEvent(event, \"start\")));\n    dispatch(setActiveIdAction(event.active.id));\n    const rect = (_event$active$rect = event.active.rect) === null || _event$active$rect === void 0 ? void 0 : (_event$active$rect$cu = _event$active$rect.current) === null || _event$active$rect$cu === void 0 ? void 0 : _event$active$rect$cu.initial;\n    if (rect) dispatch(setActiveSizeAction({\n      width: rect.width,\n      height: rect.height\n    }));\n    containersDraftRef.current = deepCloneContainers(state.containers);\n    lastOverRef.current = {\n      activeId: event.active.id,\n      overId: null,\n      overRole: null,\n      overContainerId: null\n    };\n    lastContainerMoveRef.current = {\n      fromPanelId: null,\n      toPanelId: null,\n      activeContainerId: null,\n      overChildId: null\n    };\n    touchedPanelsRef.current = new Set();\n    dispatch(softTickAction());\n  }, [dispatch, state.containers]);\n  const handleDragCancel = useCallback(() => {\n    dispatch(setDebugEventAction({\n      type: \"cancel\",\n      ts: Date.now()\n    }));\n    dispatch(setActiveIdAction(null));\n    dispatch(setActiveSizeAction(null));\n    containersDraftRef.current = null;\n    touchedPanelsRef.current = new Set();\n    dispatch(softTickAction());\n  }, [dispatch]);\n  const handleDragOver = useCallback(event => {\n    var _over$data$current$ro, _over$data2, _over$data2$current, _over$data$current$co, _over$data3, _over$data3$current, _active$data$current$, _active$data, _active$data$current;\n    const {\n      active,\n      over\n    } = event;\n    if (!over) return;\n    const nextOverRole = (_over$data$current$ro = (_over$data2 = over.data) === null || _over$data2 === void 0 ? void 0 : (_over$data2$current = _over$data2.current) === null || _over$data2$current === void 0 ? void 0 : _over$data2$current.role) !== null && _over$data$current$ro !== void 0 ? _over$data$current$ro : null;\n    const nextOverContainerId = (_over$data$current$co = (_over$data3 = over.data) === null || _over$data3 === void 0 ? void 0 : (_over$data3$current = _over$data3.current) === null || _over$data3$current === void 0 ? void 0 : _over$data3$current.containerId) !== null && _over$data$current$co !== void 0 ? _over$data$current$co : null;\n    const last = lastOverRef.current;\n    const sameOver = last.activeId === active.id && last.overId === over.id && last.overRole === nextOverRole && last.overContainerId === nextOverContainerId;\n    if (!sameOver) {\n      lastOverRef.current = {\n        activeId: active.id,\n        overId: over.id,\n        overRole: nextOverRole,\n        overContainerId: nextOverContainerId\n      };\n      dispatch(setDebugEventAction(pickEvent(event, \"over\")));\n    }\n    const activeRole = (_active$data$current$ = (_active$data = active.data) === null || _active$data === void 0 ? void 0 : (_active$data$current = _active$data.current) === null || _active$data$current === void 0 ? void 0 : _active$data$current.role) !== null && _active$data$current$ !== void 0 ? _active$data$current$ : null;\n    if (activeRole !== \"container\" && activeRole !== \"instance\") return;\n    const overInfo = getOverParent(over);\n    if (!overInfo) return;\n    if (!canDropInto(overInfo.parentRole, activeRole)) return;\n\n    // ======================================================\n    // INSTANCE -> CONTAINER (items)\n    // ======================================================\n    if (activeRole === \"instance\" && overInfo.parentRole === \"container\") {\n      var _over$data$current$ro2, _over$data4, _over$data4$current;\n      const draft = containersDraftRef.current;\n      if (!draft) return;\n      const instanceId = active.id;\n      const fromContainer = findContainerByInstanceId(instanceId, draft);\n      const toContainer = findContainerById(overInfo.parentId, draft);\n      if (!fromContainer || !toContainer) return;\n      const overRole = (_over$data$current$ro2 = (_over$data4 = over.data) === null || _over$data4 === void 0 ? void 0 : (_over$data4$current = _over$data4.current) === null || _over$data4$current === void 0 ? void 0 : _over$data4$current.role) !== null && _over$data$current$ro2 !== void 0 ? _over$data$current$ro2 : null;\n      const isOverInstance = overRole === \"instance\";\n      const overInstanceId = isOverInstance ? over.id : null;\n      const fromId = fromContainer.id;\n      const toId = toContainer.id;\n      const fromIndex = (fromContainer.items || []).indexOf(instanceId);\n      if (fromIndex === -1) return;\n\n      // compute toIndex using your existing behavior\n      let toIndex;\n      if (!overInstanceId) {\n        toIndex = (toContainer.items || []).length;\n      } else {\n        var _active$rect, _active$rect$current;\n        const idx = (toContainer.items || []).indexOf(overInstanceId);\n        toIndex = idx >= 0 ? idx : (toContainer.items || []).length;\n        const activeRect = (_active$rect = active.rect) === null || _active$rect === void 0 ? void 0 : (_active$rect$current = _active$rect.current) === null || _active$rect$current === void 0 ? void 0 : _active$rect$current.translated;\n        const overRect = over.rect;\n        const isBelow = activeRect && overRect ? activeRect.top > overRect.top + overRect.height / 2 : false;\n        toIndex = toIndex + (isBelow ? 1 : 0);\n      }\n      if (fromId === toId && !overInstanceId) return;\n      if (overInstanceId === instanceId) return;\n\n      // same container reorder\n      if (fromId === toId) {\n        if (toIndex === fromIndex) return;\n        const nextItems = arrayMove(fromContainer.items, fromIndex, toIndex);\n        containersDraftRef.current = draft.map(c => c.id === fromId ? {\n          ...c,\n          items: nextItems\n        } : c);\n        dispatch(softTickAction());\n        return;\n      }\n\n      // cross-container move via generic helper\n      const moved = moveChildAcrossParents({\n        childId: instanceId,\n        fromParent: fromContainer,\n        toParent: toContainer,\n        childKey: \"items\",\n        toIndex\n      });\n      if (!moved) return;\n      containersDraftRef.current = draft.map(c => {\n        if (c.id === moved.nextFromParent.id) return moved.nextFromParent;\n        if (c.id === moved.nextToParent.id) return moved.nextToParent;\n        return c;\n      });\n      dispatch(softTickAction());\n      return;\n    }\n\n    // ======================================================\n    // CONTAINER -> PANEL (containers)\n    // ======================================================\n    if (activeRole === \"container\" && overInfo.parentRole === \"panel\") {\n      var _active$data2, _active$data2$current, _overInfo$overChildId, _overInfo$overChildId2;\n      const activeContainerId = active.id;\n\n      // ✅ ALWAYS prefer current parent from state (because we optimistically update panels during dragOver)\n      const fromPanel = findPanelByContainerId(activeContainerId, state.panels || []) || ((_active$data2 = active.data) !== null && _active$data2 !== void 0 && (_active$data2$current = _active$data2.current) !== null && _active$data2$current !== void 0 && _active$data2$current.panelId ? findPanelById(active.data.current.panelId, state.panels || []) : null);\n      const toPanel = findPanelById(overInfo.parentId, state.panels || []);\n      if (!fromPanel || !toPanel) return;\n      // ✅ hovering empty space in same panel should not re-run \"move\"\n      if (fromPanel.id === toPanel.id && !overInfo.overChildId) {\n        return;\n      }\n\n      // insert relative to hovered container tile, else append\n      let toIndex = null;\n      if (overInfo.overChildId) {\n        const idx = (toPanel.containers || []).indexOf(overInfo.overChildId);\n        if (idx >= 0) toIndex = idx;\n      }\n\n      // de-dupe spam\n      const lastM = lastContainerMoveRef.current;\n      if (lastM.fromPanelId === fromPanel.id && lastM.toPanelId === toPanel.id && lastM.activeContainerId === activeContainerId && lastM.overChildId === ((_overInfo$overChildId = overInfo.overChildId) !== null && _overInfo$overChildId !== void 0 ? _overInfo$overChildId : null)) {\n        return;\n      }\n      lastContainerMoveRef.current = {\n        fromPanelId: fromPanel.id,\n        toPanelId: toPanel.id,\n        activeContainerId,\n        overChildId: (_overInfo$overChildId2 = overInfo.overChildId) !== null && _overInfo$overChildId2 !== void 0 ? _overInfo$overChildId2 : null\n      };\n\n      // same-panel reorder: use arrayMove for nicer behavior\n      if (fromPanel.id === toPanel.id && overInfo.overChildId) {\n        const ids = fromPanel.containers || [];\n        const fromIndex = ids.indexOf(activeContainerId);\n        const hoverIndex = ids.indexOf(overInfo.overChildId);\n        if (fromIndex === -1 || hoverIndex === -1) return;\n        if (fromIndex === hoverIndex) return;\n        const nextIds = arrayMove(ids, fromIndex, hoverIndex);\n        dispatch(updatePanelAction({\n          ...fromPanel,\n          containers: nextIds\n        }));\n        touchedPanelsRef.current.add(fromPanel.id);\n        dispatch(softTickAction());\n        return;\n      }\n\n      // cross-panel move (or append into empty panel)\n      const moved = moveChildAcrossParents({\n        childId: activeContainerId,\n        fromParent: fromPanel,\n        toParent: toPanel,\n        childKey: \"containers\",\n        toIndex\n      });\n      if (!moved) return;\n      dispatch(updatePanelAction(moved.nextFromParent));\n      dispatch(updatePanelAction(moved.nextToParent));\n      touchedPanelsRef.current.add(moved.nextFromParent.id);\n      touchedPanelsRef.current.add(moved.nextToParent.id);\n      dispatch(softTickAction());\n      return;\n    }\n  }, [dispatch, state.panels]);\n  const handleDragEnd = useCallback(event => {\n    var _active$data$current$2, _active$data3, _active$data3$current;\n    dispatch(setDebugEventAction(pickEvent(event, \"end\")));\n    const {\n      active,\n      over\n    } = event;\n    const activeRole = (_active$data$current$2 = active === null || active === void 0 ? void 0 : (_active$data3 = active.data) === null || _active$data3 === void 0 ? void 0 : (_active$data3$current = _active$data3.current) === null || _active$data3$current === void 0 ? void 0 : _active$data3$current.role) !== null && _active$data$current$2 !== void 0 ? _active$data$current$2 : null;\n    dispatch(setActiveIdAction(null));\n    dispatch(setActiveSizeAction(null));\n\n    // ======================================================\n    // CONTAINER DROP END: persist touched panels\n    // ======================================================\n    if (activeRole === \"container\") {\n      if (!over) return;\n      const touched = Array.from(touchedPanelsRef.current || []);\n      for (const panelId of touched) {\n        const panel = (state.panels || []).find(p => p.id === panelId);\n        if (panel) socket === null || socket === void 0 ? void 0 : socket.emit(\"update_panel\", {\n          panel,\n          gridId: panel.gridId\n        });\n      }\n      touchedPanelsRef.current = new Set();\n      return;\n    }\n\n    // ======================================================\n    // INSTANCE DROP END: commit + persist diffs\n    // ======================================================\n    if (!over) {\n      containersDraftRef.current = null;\n      dispatch(softTickAction());\n      return;\n    }\n    const draft = containersDraftRef.current;\n    if (draft) {\n      dispatch(setContainersAction(draft));\n      const prev = state.containers;\n      for (const nextC of draft) {\n        var _prevC$items;\n        const prevC = (prev || []).find(c => c.id === nextC.id);\n        const prevItems = (_prevC$items = prevC === null || prevC === void 0 ? void 0 : prevC.items) !== null && _prevC$items !== void 0 ? _prevC$items : [];\n        if (!itemsEqual(prevItems, nextC.items)) {\n          socket === null || socket === void 0 ? void 0 : socket.emit(\"update_container_items\", {\n            containerId: nextC.id,\n            items: nextC.items\n          });\n        }\n      }\n      containersDraftRef.current = null;\n      dispatch(softTickAction());\n    }\n  }, [dispatch, socket, state.containers, state.panels]);\n  return useMemo(() => ({\n    handleDragStart,\n    handleDragOver,\n    handleDragEnd,\n    handleDragCancel,\n    containersDraftRef,\n    getWorkingContainers\n  }), [handleDragStart, handleDragOver, handleDragEnd, handleDragCancel, getWorkingContainers]);\n}\n_s(useDndReorderCoordinator, \"nJv4rQh6IK8yk0c2COu12diMCM8=\");","map":{"version":3,"names":["useCallback","useMemo","useRef","useEffect","createContainerAction","createInstanceInContainerAction","setActiveIdAction","setActiveSizeAction","setContainersAction","setDebugEventAction","softTickAction","updatePanelAction","ACCEPTS","panel","container","uid","Date","now","toString","Math","random","slice","arrayMove","arr","from","to","copy","item","splice","deepCloneContainers","containers","map","c","items","pickEvent","event","type","_a$data","_o$data","_activeData$role","_activeData$container","_activeData$panelId","_overData$role","_overData$containerId","_overData$panelId","a","active","o","over","activeData","data","current","overData","ts","id","role","containerId","panelId","itemsEqual","b","length","i","removeOne","list","idx","indexOf","next","insertAt","index","clamped","max","min","moveChildAcrossParents","childId","fromParent","toParent","childKey","toIndex","rawFrom","rawTo","fromHad","includes","fromList","filter","x","toList","insertIndex","toNext","nextFromParent","nextToParent","findPanelById","panels","find","p","findPanelByContainerId","findContainerByInstanceId","instanceId","findContainerById","canDropInto","parentRole","childRole","getOverParent","_over$data","d","startsWith","parentId","overChildId","useDndReorderCoordinator","state","dispatch","socket","_s","containersDraftRef","lastOverRef","activeId","overId","overRole","overContainerId","lastContainerMoveRef","fromPanelId","toPanelId","activeContainerId","touchedPanelsRef","Set","getWorkingContainers","_containersDraftRef$c","handleDragStart","_event$active$rect","_event$active$rect$cu","rect","initial","width","height","handleDragCancel","handleDragOver","_over$data$current$ro","_over$data2","_over$data2$current","_over$data$current$co","_over$data3","_over$data3$current","_active$data$current$","_active$data","_active$data$current","nextOverRole","nextOverContainerId","last","sameOver","activeRole","overInfo","_over$data$current$ro2","_over$data4","_over$data4$current","draft","fromContainer","toContainer","isOverInstance","overInstanceId","fromId","toId","fromIndex","_active$rect","_active$rect$current","activeRect","translated","overRect","isBelow","top","nextItems","moved","_active$data2","_active$data2$current","_overInfo$overChildId","_overInfo$overChildId2","fromPanel","toPanel","lastM","ids","hoverIndex","nextIds","add","handleDragEnd","_active$data$current$2","_active$data3","_active$data3$current","touched","Array","emit","gridId","prev","nextC","_prevC$items","prevC","prevItems"],"sources":["/data/data/com.termux/files/home/dndkittest2/client/src/helpers/useDndReorderCoordinator.js"],"sourcesContent":["// dnd/useDndReorderCoordinator.js\nimport { useCallback, useMemo, useRef, useEffect } from \"react\";\nimport {\n  createContainerAction,\n  createInstanceInContainerAction,\n  setActiveIdAction,\n  setActiveSizeAction,\n  setContainersAction,\n  setDebugEventAction,\n  softTickAction,\n  updatePanelAction,\n} from \"../state/actions\";\n\n// ✅ Schema: who accepts what\nconst ACCEPTS = {\n  panel: [\"container\"],\n  container: [\"instance\"],\n};\n\n// ---------- utilities ----------\nfunction uid() {\n  return Date.now().toString(36) + Math.random().toString(36).slice(2, 10);\n}\n\nfunction arrayMove(arr, from, to) {\n  const copy = [...arr];\n  const [item] = copy.splice(from, 1);\n  copy.splice(to, 0, item);\n  return copy;\n}\n\nfunction deepCloneContainers(containers) {\n  return (containers || []).map((c) => ({ ...c, items: [...(c.items || [])] }));\n}\n\n// ✅ Safe event snapshot for debug UI (no circular refs)\nfunction pickEvent(event, type) {\n  const a = event?.active;\n  const o = event?.over;\n\n  const activeData = a?.data?.current || null;\n  const overData = o?.data?.current || null;\n\n  return {\n    type,\n    ts: Date.now(),\n    active: a\n      ? {\n        id: a.id,\n        role: activeData?.role ?? null,\n        containerId: activeData?.containerId ?? null,\n        panelId: activeData?.panelId ?? null,\n        data: activeData,\n      }\n      : null,\n    over: o\n      ? {\n        id: o.id,\n        role: overData?.role ?? null,\n        containerId: overData?.containerId ?? null,\n        panelId: overData?.panelId ?? null,\n        data: overData,\n      }\n      : null,\n  };\n}\n\nfunction itemsEqual(a = [], b = []) {\n  if (a === b) return true;\n  if (!a || !b) return false;\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;\n  return true;\n}\n\n// ---------- generic list move helpers ----------\nfunction removeOne(list = [], id) {\n  const idx = list.indexOf(id);\n  if (idx === -1) return { list, idx: -1 };\n  const next = [...list];\n  next.splice(idx, 1);\n  return { list: next, idx };\n}\n\nfunction insertAt(list = [], id, index) {\n  const next = [...list];\n  const clamped = Math.max(0, Math.min(next.length, index));\n  next.splice(clamped, 0, id);\n  return next;\n}\n\nfunction moveChildAcrossParents({ childId, fromParent, toParent, childKey, toIndex = null }) {\n  if (!fromParent || !toParent) return null;\n\n  const rawFrom = fromParent[childKey] || [];\n  const rawTo = toParent[childKey] || [];\n\n  const fromHad = rawFrom.includes(childId);\n\n  // ✅ remove from BOTH sides first to prevent duplicates during dragOver spam\n  const fromList = rawFrom.filter((x) => x !== childId);\n  const toList = rawTo.filter((x) => x !== childId);\n\n  // If it's a true cross-parent move, and the source didn't actually have it, bail\n  if (fromParent.id !== toParent.id && !fromHad) return null;\n\n  const insertIndex = toIndex == null ? toList.length : toIndex;\n  const toNext = insertAt(toList, childId, insertIndex);\n\n  return {\n    nextFromParent: { ...fromParent, [childKey]: fromList },\n    nextToParent: { ...toParent, [childKey]: toNext },\n  };\n}\n\n// ---------- parent finders ----------\nfunction findPanelById(panelId, panels = []) {\n  return (panels || []).find((p) => p.id === panelId) || null;\n}\n\nfunction findPanelByContainerId(containerId, panels = []) {\n  return (panels || []).find((p) => (p.containers || []).includes(containerId)) || null;\n}\n\nfunction findContainerByInstanceId(instanceId, list = []) {\n  return (list || []).find((c) => (c.items || []).includes(instanceId)) || null;\n}\n\nfunction findContainerById(containerId, list = []) {\n  return (list || []).find((c) => c.id === containerId) || null;\n}\n\nfunction canDropInto(parentRole, childRole) {\n  return (ACCEPTS[parentRole] || []).includes(childRole);\n}\n\n/**\n * Normalizes over into:\n *   { parentRole: \"panel\"|\"container\", parentId, overChildId? }\n */\nfunction getOverParent(over) {\n  if (!over) return null;\n  const d = over.data?.current || {};\n\n  // ✅ Container list/top/bottom => parent is container\n  if (d?.containerId && typeof d?.role === \"string\" && d.role.startsWith(\"container:\")) {\n    return { parentRole: \"container\", parentId: d.containerId };\n  }\n\n  // ✅ Hovering an instance => parent is container\n  if (d?.role === \"instance\" && d?.containerId) {\n    return { parentRole: \"container\", parentId: d.containerId, overChildId: over.id };\n  }\n\n  // ✅ Panel dropzone => parent is panel\n  if (d?.role === \"panel:drop\" && d?.panelId) {\n    return { parentRole: \"panel\", parentId: d.panelId };\n  }\n\n  // ✅ Hovering a container tile => parent is panel (insert relative to that container)\n  if (d?.role === \"container\" && d?.panelId) {\n    return { parentRole: \"panel\", parentId: d.panelId, overChildId: over.id };\n  }\n\n  return null;\n}\n\n// ---------- hook ----------\nexport function useDndReorderCoordinator({ state, dispatch, socket }) {\n  // instance soft-sort draft ref (kept out of reducer on purpose)\n  const containersDraftRef = useRef(null);\n\n  const lastOverRef = useRef({\n    activeId: null,\n    overId: null,\n    overRole: null,\n    overContainerId: null,\n  });\n\n  // ✅ de-dupe spam for panel container moves\n  const lastContainerMoveRef = useRef({\n    fromPanelId: null,\n    toPanelId: null,\n    activeContainerId: null,\n    overChildId: null,\n  });\n\n  // ✅ track which panels were touched, so dragEnd persists once\n  const touchedPanelsRef = useRef(new Set());\n\n  const getWorkingContainers = useCallback(() => {\n    return containersDraftRef.current ?? state.containers;\n  }, [state.containers]);\n\n  const handleDragStart = useCallback(\n    (event) => {\n      dispatch(setDebugEventAction(pickEvent(event, \"start\")));\n      dispatch(setActiveIdAction(event.active.id));\n\n      const rect = event.active.rect?.current?.initial;\n      if (rect) dispatch(setActiveSizeAction({ width: rect.width, height: rect.height }));\n\n      containersDraftRef.current = deepCloneContainers(state.containers);\n\n      lastOverRef.current = {\n        activeId: event.active.id,\n        overId: null,\n        overRole: null,\n        overContainerId: null,\n      };\n\n      lastContainerMoveRef.current = {\n        fromPanelId: null,\n        toPanelId: null,\n        activeContainerId: null,\n        overChildId: null,\n      };\n\n      touchedPanelsRef.current = new Set();\n\n      dispatch(softTickAction());\n    },\n    [dispatch, state.containers]\n  );\n\n  const handleDragCancel = useCallback(() => {\n    dispatch(setDebugEventAction({ type: \"cancel\", ts: Date.now() }));\n    dispatch(setActiveIdAction(null));\n    dispatch(setActiveSizeAction(null));\n\n    containersDraftRef.current = null;\n    touchedPanelsRef.current = new Set();\n\n    dispatch(softTickAction());\n  }, [dispatch]);\n\n  const handleDragOver = useCallback(\n    (event) => {\n      const { active, over } = event;\n      if (!over) return;\n\n      const nextOverRole = over.data?.current?.role ?? null;\n      const nextOverContainerId = over.data?.current?.containerId ?? null;\n\n      const last = lastOverRef.current;\n      const sameOver =\n        last.activeId === active.id &&\n        last.overId === over.id &&\n        last.overRole === nextOverRole &&\n        last.overContainerId === nextOverContainerId;\n\n      if (!sameOver) {\n        lastOverRef.current = {\n          activeId: active.id,\n          overId: over.id,\n          overRole: nextOverRole,\n          overContainerId: nextOverContainerId,\n        };\n        dispatch(setDebugEventAction(pickEvent(event, \"over\")));\n      }\n\n      const activeRole = active.data?.current?.role ?? null;\n      if (activeRole !== \"container\" && activeRole !== \"instance\") return;\n\n      const overInfo = getOverParent(over);\n      if (!overInfo) return;\n\n      if (!canDropInto(overInfo.parentRole, activeRole)) return;\n\n      // ======================================================\n      // INSTANCE -> CONTAINER (items)\n      // ======================================================\n      if (activeRole === \"instance\" && overInfo.parentRole === \"container\") {\n        const draft = containersDraftRef.current;\n        if (!draft) return;\n\n        const instanceId = active.id;\n        const fromContainer = findContainerByInstanceId(instanceId, draft);\n        const toContainer = findContainerById(overInfo.parentId, draft);\n        if (!fromContainer || !toContainer) return;\n\n        const overRole = over.data?.current?.role ?? null;\n        const isOverInstance = overRole === \"instance\";\n        const overInstanceId = isOverInstance ? over.id : null;\n\n        const fromId = fromContainer.id;\n        const toId = toContainer.id;\n\n        const fromIndex = (fromContainer.items || []).indexOf(instanceId);\n        if (fromIndex === -1) return;\n\n        // compute toIndex using your existing behavior\n        let toIndex;\n        if (!overInstanceId) {\n          toIndex = (toContainer.items || []).length;\n        } else {\n          const idx = (toContainer.items || []).indexOf(overInstanceId);\n          toIndex = idx >= 0 ? idx : (toContainer.items || []).length;\n\n          const activeRect = active.rect?.current?.translated;\n          const overRect = over.rect;\n          const isBelow =\n            activeRect && overRect\n              ? activeRect.top > overRect.top + overRect.height / 2\n              : false;\n\n          toIndex = toIndex + (isBelow ? 1 : 0);\n        }\n\n        if (fromId === toId && !overInstanceId) return;\n        if (overInstanceId === instanceId) return;\n\n        // same container reorder\n        if (fromId === toId) {\n          if (toIndex === fromIndex) return;\n          const nextItems = arrayMove(fromContainer.items, fromIndex, toIndex);\n          containersDraftRef.current = draft.map((c) =>\n            c.id === fromId ? { ...c, items: nextItems } : c\n          );\n          dispatch(softTickAction());\n          return;\n        }\n\n        // cross-container move via generic helper\n        const moved = moveChildAcrossParents({\n          childId: instanceId,\n          fromParent: fromContainer,\n          toParent: toContainer,\n          childKey: \"items\",\n          toIndex,\n        });\n        if (!moved) return;\n\n        containersDraftRef.current = draft.map((c) => {\n          if (c.id === moved.nextFromParent.id) return moved.nextFromParent;\n          if (c.id === moved.nextToParent.id) return moved.nextToParent;\n          return c;\n        });\n\n        dispatch(softTickAction());\n        return;\n      }\n\n      // ======================================================\n      // CONTAINER -> PANEL (containers)\n      // ======================================================\n      if (activeRole === \"container\" && overInfo.parentRole === \"panel\") {\n        const activeContainerId = active.id;\n\n        // ✅ ALWAYS prefer current parent from state (because we optimistically update panels during dragOver)\n        const fromPanel =\n          findPanelByContainerId(activeContainerId, state.panels || []) ||\n          (active.data?.current?.panelId\n            ? findPanelById(active.data.current.panelId, state.panels || [])\n            : null);\n\n\n        const toPanel = findPanelById(overInfo.parentId, state.panels || []);\n\n        if (!fromPanel || !toPanel) return;\n        // ✅ hovering empty space in same panel should not re-run \"move\"\n        if (fromPanel.id === toPanel.id && !overInfo.overChildId) {\n          return;\n        }\n\n        // insert relative to hovered container tile, else append\n        let toIndex = null;\n        if (overInfo.overChildId) {\n          const idx = (toPanel.containers || []).indexOf(overInfo.overChildId);\n          if (idx >= 0) toIndex = idx;\n        }\n\n        // de-dupe spam\n        const lastM = lastContainerMoveRef.current;\n        if (\n          lastM.fromPanelId === fromPanel.id &&\n          lastM.toPanelId === toPanel.id &&\n          lastM.activeContainerId === activeContainerId &&\n          lastM.overChildId === (overInfo.overChildId ?? null)\n        ) {\n          return;\n        }\n        lastContainerMoveRef.current = {\n          fromPanelId: fromPanel.id,\n          toPanelId: toPanel.id,\n          activeContainerId,\n          overChildId: overInfo.overChildId ?? null,\n        };\n\n        // same-panel reorder: use arrayMove for nicer behavior\n        if (fromPanel.id === toPanel.id && overInfo.overChildId) {\n          const ids = fromPanel.containers || [];\n          const fromIndex = ids.indexOf(activeContainerId);\n          const hoverIndex = ids.indexOf(overInfo.overChildId);\n          if (fromIndex === -1 || hoverIndex === -1) return;\n          if (fromIndex === hoverIndex) return;\n\n          const nextIds = arrayMove(ids, fromIndex, hoverIndex);\n          dispatch(updatePanelAction({ ...fromPanel, containers: nextIds }));\n          touchedPanelsRef.current.add(fromPanel.id);\n          dispatch(softTickAction());\n          return;\n        }\n\n        // cross-panel move (or append into empty panel)\n        const moved = moveChildAcrossParents({\n          childId: activeContainerId,\n          fromParent: fromPanel,\n          toParent: toPanel,\n          childKey: \"containers\",\n          toIndex,\n        });\n        if (!moved) return;\n\n        dispatch(updatePanelAction(moved.nextFromParent));\n        dispatch(updatePanelAction(moved.nextToParent));\n\n        touchedPanelsRef.current.add(moved.nextFromParent.id);\n        touchedPanelsRef.current.add(moved.nextToParent.id);\n\n        dispatch(softTickAction());\n        return;\n      }\n    },\n    [dispatch, state.panels]\n  );\n\n  const handleDragEnd = useCallback(\n    (event) => {\n      dispatch(setDebugEventAction(pickEvent(event, \"end\")));\n\n      const { active, over } = event;\n      const activeRole = active?.data?.current?.role ?? null;\n\n      dispatch(setActiveIdAction(null));\n      dispatch(setActiveSizeAction(null));\n\n      // ======================================================\n      // CONTAINER DROP END: persist touched panels\n      // ======================================================\n      if (activeRole === \"container\") {\n        if (!over) return;\n\n        const touched = Array.from(touchedPanelsRef.current || []);\n        for (const panelId of touched) {\n          const panel = (state.panels || []).find((p) => p.id === panelId);\n          if (panel) socket?.emit(\"update_panel\", { panel, gridId: panel.gridId });\n        }\n\n        touchedPanelsRef.current = new Set();\n        return;\n      }\n\n      // ======================================================\n      // INSTANCE DROP END: commit + persist diffs\n      // ======================================================\n      if (!over) {\n        containersDraftRef.current = null;\n        dispatch(softTickAction());\n        return;\n      }\n\n      const draft = containersDraftRef.current;\n\n      if (draft) {\n        dispatch(setContainersAction(draft));\n\n        const prev = state.containers;\n        for (const nextC of draft) {\n          const prevC = (prev || []).find((c) => c.id === nextC.id);\n          const prevItems = prevC?.items ?? [];\n          if (!itemsEqual(prevItems, nextC.items)) {\n            socket?.emit(\"update_container_items\", {\n              containerId: nextC.id,\n              items: nextC.items,\n            });\n          }\n        }\n\n        containersDraftRef.current = null;\n        dispatch(softTickAction());\n      }\n    },\n    [dispatch, socket, state.containers, state.panels]\n  );\n\n  return useMemo(\n    () => ({\n      handleDragStart,\n      handleDragOver,\n      handleDragEnd,\n      handleDragCancel,\n      containersDraftRef,\n      getWorkingContainers,\n    }),\n    [handleDragStart, handleDragOver, handleDragEnd, handleDragCancel, getWorkingContainers]\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}