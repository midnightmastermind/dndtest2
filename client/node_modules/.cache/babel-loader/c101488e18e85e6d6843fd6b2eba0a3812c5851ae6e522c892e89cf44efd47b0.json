{"ast":null,"code":"var _s = $RefreshSig$();\n// dnd/useDndReorderCoordinator.js\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { addContainerAction, addInstanceToContainerAction, setActiveIdAction, setActiveSizeAction, setContainersAction, setDebugEventAction, softTickAction } from \"../state/actions\";\n\n// ---------- utilities ----------\nfunction uid() {\n  return Date.now().toString(36) + Math.random().toString(36).slice(2, 10);\n}\nfunction arrayMove(arr, from, to) {\n  const copy = [...arr];\n  const [item] = copy.splice(from, 1);\n  copy.splice(to, 0, item);\n  return copy;\n}\nfunction deepCloneContainers(containers) {\n  return containers.map(c => ({\n    ...c,\n    items: [...c.items]\n  }));\n}\n\n// âœ… Safe event snapshot for debug UI (no circular refs)\nfunction pickEvent(event, type) {\n  var _a$data, _o$data, _activeData$role, _activeData$container, _overData$role, _overData$containerId;\n  const a = event === null || event === void 0 ? void 0 : event.active;\n  const o = event === null || event === void 0 ? void 0 : event.over;\n  const activeData = (a === null || a === void 0 ? void 0 : (_a$data = a.data) === null || _a$data === void 0 ? void 0 : _a$data.current) || null;\n  const overData = (o === null || o === void 0 ? void 0 : (_o$data = o.data) === null || _o$data === void 0 ? void 0 : _o$data.current) || null;\n  return {\n    type,\n    ts: Date.now(),\n    active: a ? {\n      id: a.id,\n      role: (_activeData$role = activeData === null || activeData === void 0 ? void 0 : activeData.role) !== null && _activeData$role !== void 0 ? _activeData$role : null,\n      containerId: (_activeData$container = activeData === null || activeData === void 0 ? void 0 : activeData.containerId) !== null && _activeData$container !== void 0 ? _activeData$container : null,\n      data: activeData\n    } : null,\n    over: o ? {\n      id: o.id,\n      role: (_overData$role = overData === null || overData === void 0 ? void 0 : overData.role) !== null && _overData$role !== void 0 ? _overData$role : null,\n      containerId: (_overData$containerId = overData === null || overData === void 0 ? void 0 : overData.containerId) !== null && _overData$containerId !== void 0 ? _overData$containerId : null,\n      data: overData\n    } : null\n  };\n}\nfunction getOverContainerId(over) {\n  var _over$data, _over$data$current;\n  if (!over) return null;\n\n  // preferred: explicit data\n  const cid = (_over$data = over.data) === null || _over$data === void 0 ? void 0 : (_over$data$current = _over$data.current) === null || _over$data$current === void 0 ? void 0 : _over$data$current.containerId;\n  if (cid) return cid;\n\n  // fallback: parse droppable id patterns (list:/top:/bottom:)\n  if (typeof over.id === \"string\") {\n    if (over.id.startsWith(\"list:\")) return over.id.slice(\"list:\".length);\n    if (over.id.startsWith(\"top:\")) return over.id.slice(\"top:\".length);\n    if (over.id.startsWith(\"bottom:\")) return over.id.slice(\"bottom:\".length);\n  }\n  return null;\n}\nfunction findContainerByInstanceId(instanceId, list) {\n  return list.find(c => c.items.includes(instanceId));\n}\n\n// ---------- hook ----------\nexport function useDndReorderCoordinator({\n  state,\n  dispatch\n}) {\n  _s();\n  // soft-sort draft ref (kept out of reducer on purpose)\n  const containersDraftRef = useRef(null);\n\n  // throttle debugEvent (only update when meaningful change)\n  const lastOverRef = useRef({\n    activeId: null,\n    overId: null,\n    overRole: null,\n    overContainerId: null\n  });\n  const addContainer = useCallback(() => {\n    const id = uid();\n    dispatch(addContainerAction({\n      id,\n      label: `List ${state.containers.length + 1}`\n    }));\n  }, [dispatch, state.containers.length]);\n  const addInstanceToContainer = useCallback(containerId => {\n    const instanceId = uid();\n    dispatch(addInstanceToContainerAction({\n      containerId,\n      instance: {\n        id: instanceId,\n        label: `Item ${state.instances.length + 1}`\n      }\n    }));\n  }, [dispatch, state.instances.length]);\n  const getWorkingContainers = useCallback(() => {\n    var _containersDraftRef$c;\n    return (_containersDraftRef$c = containersDraftRef.current) !== null && _containersDraftRef$c !== void 0 ? _containersDraftRef$c : state.containers;\n  }, [state.containers]);\n  const handleDragStart = useCallback(event => {\n    var _event$active$rect, _event$active$rect$cu;\n    dispatch(setDebugEventAction(pickEvent(event, \"start\")));\n    dispatch(setActiveIdAction(event.active.id));\n    const rect = (_event$active$rect = event.active.rect) === null || _event$active$rect === void 0 ? void 0 : (_event$active$rect$cu = _event$active$rect.current) === null || _event$active$rect$cu === void 0 ? void 0 : _event$active$rect$cu.initial;\n    if (rect) dispatch(setActiveSizeAction({\n      width: rect.width,\n      height: rect.height\n    }));\n\n    // start draft snapshot\n    containersDraftRef.current = deepCloneContainers(state.containers);\n\n    // reset debug throttle baseline\n    lastOverRef.current = {\n      activeId: event.active.id,\n      overId: null,\n      overRole: null,\n      overContainerId: null\n    };\n    dispatch(softTickAction());\n  }, [dispatch, state.containers]);\n  const handleDragCancel = useCallback(() => {\n    dispatch(setDebugEventAction({\n      type: \"cancel\",\n      ts: Date.now()\n    }));\n    dispatch(setActiveIdAction(null));\n    dispatch(setActiveSizeAction(null));\n    containersDraftRef.current = null;\n    dispatch(softTickAction());\n  }, [dispatch]);\n  const handleDragOver = useCallback(event => {\n    var _over$data$current$ro, _over$data$current2, _over$data$current$co, _over$data$current3, _active$data$current;\n    console.log(\"dragover:start\");\n    const {\n      active,\n      over\n    } = event;\n    if (!over) return;\n\n    // ---- throttle debugEvent (only if meaningful change) ----\n    const nextOverRole = (_over$data$current$ro = (_over$data$current2 = over.data.current) === null || _over$data$current2 === void 0 ? void 0 : _over$data$current2.role) !== null && _over$data$current$ro !== void 0 ? _over$data$current$ro : null;\n    const nextOverContainerId = (_over$data$current$co = (_over$data$current3 = over.data.current) === null || _over$data$current3 === void 0 ? void 0 : _over$data$current3.containerId) !== null && _over$data$current$co !== void 0 ? _over$data$current$co : typeof over.id === \"string\" ? over.id : null;\n    const last = lastOverRef.current;\n    const sameOver = last.activeId === active.id && last.overId === over.id && last.overRole === nextOverRole && last.overContainerId === nextOverContainerId;\n    if (!sameOver) {\n      lastOverRef.current = {\n        activeId: active.id,\n        overId: over.id,\n        overRole: nextOverRole,\n        overContainerId: nextOverContainerId\n      };\n      dispatch(setDebugEventAction(pickEvent(event, \"over\")));\n    }\n    const draft = containersDraftRef.current;\n    if (!draft) return;\n    const activeRole = (_active$data$current = active.data.current) === null || _active$data$current === void 0 ? void 0 : _active$data$current.role;\n    const overRole = nextOverRole;\n\n    // A) Dragging a CONTAINER (still disabled)\n    if (activeRole === \"container\") return;\n\n    // B) Dragging an INSTANCE (sortable + cross-container)\n    if (activeRole !== \"instance\") return;\n    const instanceId = active.id;\n    const fromContainer = findContainerByInstanceId(instanceId, draft);\n    if (!fromContainer) return;\n    const toContainerId = getOverContainerId(over);\n    if (!toContainerId) return;\n    const toContainer = draft.find(c => c.id === toContainerId);\n    if (!toContainer) return;\n    const fromId = fromContainer.id;\n    const toId = toContainer.id;\n    const fromIndex = fromContainer.items.indexOf(instanceId);\n    if (fromIndex === -1) return;\n    const isOverInstance = overRole === \"instance\";\n    const overInstanceId = isOverInstance ? over.id : null;\n\n    // compute base toIndex\n    let toIndex;\n    if (!overInstanceId) {\n      toIndex = toContainer.items.length;\n    } else {\n      const idx = toContainer.items.indexOf(overInstanceId);\n      toIndex = idx >= 0 ? idx : toContainer.items.length;\n\n      // ðŸ‘‡ midpoint logic (insert after when dragging downward)\n      const activeRect = active.rect.current.translated;\n      const overRect = over.rect;\n      const isBelow = activeRect && overRect ? activeRect.top > overRect.top + overRect.height / 2 : false;\n      toIndex = toIndex + (isBelow ? 1 : 0);\n    }\n\n    // -----------------------------\n    // Guards\n    // -----------------------------\n    if (fromId === toId && !overInstanceId) return;\n    if (overInstanceId === instanceId) return;\n\n    // -----------------------------\n    // Same container reorder\n    // -----------------------------\n    if (fromId === toId) {\n      if (toIndex === fromIndex) return;\n      const nextItems = arrayMove(fromContainer.items, fromIndex, toIndex);\n      containersDraftRef.current = draft.map(c => c.id === fromId ? {\n        ...c,\n        items: nextItems\n      } : c);\n      dispatch(softTickAction());\n      console.log(\"dragover:end\");\n      return;\n    }\n\n    // -----------------------------\n    // Cross-container move\n    // -----------------------------\n    const nextFromItems = fromContainer.items.filter(id => id !== instanceId);\n    const clamped = Math.max(0, Math.min(toContainer.items.length, toIndex));\n    const nextToItems = [...toContainer.items];\n    nextToItems.splice(clamped, 0, instanceId);\n    containersDraftRef.current = draft.map(c => {\n      if (c.id === fromId) return {\n        ...c,\n        items: nextFromItems\n      };\n      if (c.id === toId) return {\n        ...c,\n        items: nextToItems\n      };\n      return c;\n    });\n    dispatch(softTickAction());\n    console.log(\"dragover:end\");\n  }, [dispatch]);\n  const handleDragEnd = useCallback(event => {\n    dispatch(setDebugEventAction(pickEvent(event, \"end\")));\n    const {\n      over\n    } = event;\n    dispatch(setActiveIdAction(null));\n    dispatch(setActiveSizeAction(null));\n\n    // if no drop target, revert\n    if (!over) {\n      containersDraftRef.current = null;\n      dispatch(softTickAction());\n      return;\n    }\n\n    // commit draft if present\n    if (containersDraftRef.current) {\n      dispatch(setContainersAction(containersDraftRef.current));\n      containersDraftRef.current = null;\n      dispatch(softTickAction());\n    }\n  }, [dispatch]);\n  return useMemo(() => ({\n    // creators\n    addContainer,\n    addInstanceToContainer,\n    // handlers\n    handleDragStart,\n    handleDragOver,\n    handleDragEnd,\n    handleDragCancel,\n    // draft + helpers\n    containersDraftRef,\n    getWorkingContainers\n  }), [addContainer, addInstanceToContainer, handleDragStart, handleDragOver, handleDragEnd, handleDragCancel, getWorkingContainers]);\n}\n_s(useDndReorderCoordinator, \"8qlwMif0Hcw5/DmEbsYzeCJJncU=\");","map":{"version":3,"names":["useCallback","useMemo","useRef","addContainerAction","addInstanceToContainerAction","setActiveIdAction","setActiveSizeAction","setContainersAction","setDebugEventAction","softTickAction","uid","Date","now","toString","Math","random","slice","arrayMove","arr","from","to","copy","item","splice","deepCloneContainers","containers","map","c","items","pickEvent","event","type","_a$data","_o$data","_activeData$role","_activeData$container","_overData$role","_overData$containerId","a","active","o","over","activeData","data","current","overData","ts","id","role","containerId","getOverContainerId","_over$data","_over$data$current","cid","startsWith","length","findContainerByInstanceId","instanceId","list","find","includes","useDndReorderCoordinator","state","dispatch","_s","containersDraftRef","lastOverRef","activeId","overId","overRole","overContainerId","addContainer","label","addInstanceToContainer","instance","instances","getWorkingContainers","_containersDraftRef$c","handleDragStart","_event$active$rect","_event$active$rect$cu","rect","initial","width","height","handleDragCancel","handleDragOver","_over$data$current$ro","_over$data$current2","_over$data$current$co","_over$data$current3","_active$data$current","console","log","nextOverRole","nextOverContainerId","last","sameOver","draft","activeRole","fromContainer","toContainerId","toContainer","fromId","toId","fromIndex","indexOf","isOverInstance","overInstanceId","toIndex","idx","activeRect","translated","overRect","isBelow","top","nextItems","nextFromItems","filter","clamped","max","min","nextToItems","handleDragEnd"],"sources":["/home/joshpoms/dndtest2/src/helpers/useDndReorderCoordinator.js"],"sourcesContent":["// dnd/useDndReorderCoordinator.js\nimport { useCallback, useMemo, useRef } from \"react\";\nimport {\n  addContainerAction,\n  addInstanceToContainerAction,\n  setActiveIdAction,\n  setActiveSizeAction,\n  setContainersAction,\n  setDebugEventAction,\n  softTickAction,\n} from \"../state/actions\";\n\n// ---------- utilities ----------\nfunction uid() {\n  return Date.now().toString(36) + Math.random().toString(36).slice(2, 10);\n}\n\nfunction arrayMove(arr, from, to) {\n  const copy = [...arr];\n  const [item] = copy.splice(from, 1);\n  copy.splice(to, 0, item);\n  return copy;\n}\n\nfunction deepCloneContainers(containers) {\n  return containers.map((c) => ({ ...c, items: [...c.items] }));\n}\n\n// âœ… Safe event snapshot for debug UI (no circular refs)\nfunction pickEvent(event, type) {\n  const a = event?.active;\n  const o = event?.over;\n\n  const activeData = a?.data?.current || null;\n  const overData = o?.data?.current || null;\n\n  return {\n    type,\n    ts: Date.now(),\n    active: a\n      ? {\n          id: a.id,\n          role: activeData?.role ?? null,\n          containerId: activeData?.containerId ?? null,\n          data: activeData,\n        }\n      : null,\n    over: o\n      ? {\n          id: o.id,\n          role: overData?.role ?? null,\n          containerId: overData?.containerId ?? null,\n          data: overData,\n        }\n      : null,\n  };\n}\n\nfunction getOverContainerId(over) {\n  if (!over) return null;\n\n  // preferred: explicit data\n  const cid = over.data?.current?.containerId;\n  if (cid) return cid;\n\n  // fallback: parse droppable id patterns (list:/top:/bottom:)\n  if (typeof over.id === \"string\") {\n    if (over.id.startsWith(\"list:\")) return over.id.slice(\"list:\".length);\n    if (over.id.startsWith(\"top:\")) return over.id.slice(\"top:\".length);\n    if (over.id.startsWith(\"bottom:\")) return over.id.slice(\"bottom:\".length);\n  }\n\n  return null;\n}\n\nfunction findContainerByInstanceId(instanceId, list) {\n  return list.find((c) => c.items.includes(instanceId));\n}\n\n// ---------- hook ----------\nexport function useDndReorderCoordinator({ state, dispatch }) {\n  // soft-sort draft ref (kept out of reducer on purpose)\n  const containersDraftRef = useRef(null);\n\n  // throttle debugEvent (only update when meaningful change)\n  const lastOverRef = useRef({\n    activeId: null,\n    overId: null,\n    overRole: null,\n    overContainerId: null,\n  });\n\n  const addContainer = useCallback(() => {\n    const id = uid();\n    dispatch(addContainerAction({ id, label: `List ${state.containers.length + 1}` }));\n  }, [dispatch, state.containers.length]);\n\n  const addInstanceToContainer = useCallback(\n    (containerId) => {\n      const instanceId = uid();\n      dispatch(\n        addInstanceToContainerAction({\n          containerId,\n          instance: { id: instanceId, label: `Item ${state.instances.length + 1}` },\n        })\n      );\n    },\n    [dispatch, state.instances.length]\n  );\n\n  const getWorkingContainers = useCallback(() => {\n    return containersDraftRef.current ?? state.containers;\n  }, [state.containers]);\n\n  const handleDragStart = useCallback(\n    (event) => {\n      dispatch(setDebugEventAction(pickEvent(event, \"start\")));\n      dispatch(setActiveIdAction(event.active.id));\n\n      const rect = event.active.rect?.current?.initial;\n      if (rect) dispatch(setActiveSizeAction({ width: rect.width, height: rect.height }));\n\n      // start draft snapshot\n      containersDraftRef.current = deepCloneContainers(state.containers);\n\n      // reset debug throttle baseline\n      lastOverRef.current = {\n        activeId: event.active.id,\n        overId: null,\n        overRole: null,\n        overContainerId: null,\n      };\n\n      dispatch(softTickAction());\n    },\n    [dispatch, state.containers]\n  );\n\n  const handleDragCancel = useCallback(() => {\n    dispatch(setDebugEventAction({ type: \"cancel\", ts: Date.now() }));\n    dispatch(setActiveIdAction(null));\n    dispatch(setActiveSizeAction(null));\n\n    containersDraftRef.current = null;\n    dispatch(softTickAction());\n  }, [dispatch]);\n\n  const handleDragOver = useCallback(\n    (event) => {\n      console.log(\"dragover:start\");\n\n      const { active, over } = event;\n      if (!over) return;\n\n      // ---- throttle debugEvent (only if meaningful change) ----\n      const nextOverRole = over.data.current?.role ?? null;\n      const nextOverContainerId =\n        over.data.current?.containerId ?? (typeof over.id === \"string\" ? over.id : null);\n\n      const last = lastOverRef.current;\n      const sameOver =\n        last.activeId === active.id &&\n        last.overId === over.id &&\n        last.overRole === nextOverRole &&\n        last.overContainerId === nextOverContainerId;\n\n      if (!sameOver) {\n        lastOverRef.current = {\n          activeId: active.id,\n          overId: over.id,\n          overRole: nextOverRole,\n          overContainerId: nextOverContainerId,\n        };\n        dispatch(setDebugEventAction(pickEvent(event, \"over\")));\n      }\n\n      const draft = containersDraftRef.current;\n      if (!draft) return;\n\n      const activeRole = active.data.current?.role;\n      const overRole = nextOverRole;\n\n      // A) Dragging a CONTAINER (still disabled)\n      if (activeRole === \"container\") return;\n\n      // B) Dragging an INSTANCE (sortable + cross-container)\n      if (activeRole !== \"instance\") return;\n\n      const instanceId = active.id;\n\n      const fromContainer = findContainerByInstanceId(instanceId, draft);\n      if (!fromContainer) return;\n\n      const toContainerId = getOverContainerId(over);\n      if (!toContainerId) return;\n\n      const toContainer = draft.find((c) => c.id === toContainerId);\n      if (!toContainer) return;\n\n      const fromId = fromContainer.id;\n      const toId = toContainer.id;\n\n      const fromIndex = fromContainer.items.indexOf(instanceId);\n      if (fromIndex === -1) return;\n\n      const isOverInstance = overRole === \"instance\";\n      const overInstanceId = isOverInstance ? over.id : null;\n\n      // compute base toIndex\n      let toIndex;\n      if (!overInstanceId) {\n        toIndex = toContainer.items.length;\n      } else {\n        const idx = toContainer.items.indexOf(overInstanceId);\n        toIndex = idx >= 0 ? idx : toContainer.items.length;\n\n        // ðŸ‘‡ midpoint logic (insert after when dragging downward)\n        const activeRect = active.rect.current.translated;\n        const overRect = over.rect;\n\n        const isBelow =\n          activeRect && overRect\n            ? activeRect.top > overRect.top + overRect.height / 2\n            : false;\n\n        toIndex = toIndex + (isBelow ? 1 : 0);\n      }\n\n      // -----------------------------\n      // Guards\n      // -----------------------------\n      if (fromId === toId && !overInstanceId) return;\n      if (overInstanceId === instanceId) return;\n\n      // -----------------------------\n      // Same container reorder\n      // -----------------------------\n      if (fromId === toId) {\n        if (toIndex === fromIndex) return;\n\n        const nextItems = arrayMove(fromContainer.items, fromIndex, toIndex);\n\n        containersDraftRef.current = draft.map((c) =>\n          c.id === fromId ? { ...c, items: nextItems } : c\n        );\n\n        dispatch(softTickAction());\n        console.log(\"dragover:end\");\n        return;\n      }\n\n      // -----------------------------\n      // Cross-container move\n      // -----------------------------\n      const nextFromItems = fromContainer.items.filter((id) => id !== instanceId);\n\n      const clamped = Math.max(0, Math.min(toContainer.items.length, toIndex));\n      const nextToItems = [...toContainer.items];\n      nextToItems.splice(clamped, 0, instanceId);\n\n      containersDraftRef.current = draft.map((c) => {\n        if (c.id === fromId) return { ...c, items: nextFromItems };\n        if (c.id === toId) return { ...c, items: nextToItems };\n        return c;\n      });\n\n      dispatch(softTickAction());\n      console.log(\"dragover:end\");\n    },\n    [dispatch]\n  );\n\n  const handleDragEnd = useCallback(\n    (event) => {\n      dispatch(setDebugEventAction(pickEvent(event, \"end\")));\n\n      const { over } = event;\n\n      dispatch(setActiveIdAction(null));\n      dispatch(setActiveSizeAction(null));\n\n      // if no drop target, revert\n      if (!over) {\n        containersDraftRef.current = null;\n        dispatch(softTickAction());\n        return;\n      }\n\n      // commit draft if present\n      if (containersDraftRef.current) {\n        dispatch(setContainersAction(containersDraftRef.current));\n        containersDraftRef.current = null;\n        dispatch(softTickAction());\n      }\n    },\n    [dispatch]\n  );\n\n  return useMemo(\n    () => ({\n      // creators\n      addContainer,\n      addInstanceToContainer,\n\n      // handlers\n      handleDragStart,\n      handleDragOver,\n      handleDragEnd,\n      handleDragCancel,\n\n      // draft + helpers\n      containersDraftRef,\n      getWorkingContainers,\n    }),\n    [\n      addContainer,\n      addInstanceToContainer,\n      handleDragStart,\n      handleDragOver,\n      handleDragEnd,\n      handleDragCancel,\n      getWorkingContainers,\n    ]\n  );\n}\n"],"mappings":";AAAA;AACA,SAASA,WAAW,EAAEC,OAAO,EAAEC,MAAM,QAAQ,OAAO;AACpD,SACEC,kBAAkB,EAClBC,4BAA4B,EAC5BC,iBAAiB,EACjBC,mBAAmB,EACnBC,mBAAmB,EACnBC,mBAAmB,EACnBC,cAAc,QACT,kBAAkB;;AAEzB;AACA,SAASC,GAAGA,CAAA,EAAG;EACb,OAAOC,IAAI,CAACC,GAAG,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC,CAACF,QAAQ,CAAC,EAAE,CAAC,CAACG,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;AAC1E;AAEA,SAASC,SAASA,CAACC,GAAG,EAAEC,IAAI,EAAEC,EAAE,EAAE;EAChC,MAAMC,IAAI,GAAG,CAAC,GAAGH,GAAG,CAAC;EACrB,MAAM,CAACI,IAAI,CAAC,GAAGD,IAAI,CAACE,MAAM,CAACJ,IAAI,EAAE,CAAC,CAAC;EACnCE,IAAI,CAACE,MAAM,CAACH,EAAE,EAAE,CAAC,EAAEE,IAAI,CAAC;EACxB,OAAOD,IAAI;AACb;AAEA,SAASG,mBAAmBA,CAACC,UAAU,EAAE;EACvC,OAAOA,UAAU,CAACC,GAAG,CAAEC,CAAC,KAAM;IAAE,GAAGA,CAAC;IAAEC,KAAK,EAAE,CAAC,GAAGD,CAAC,CAACC,KAAK;EAAE,CAAC,CAAC,CAAC;AAC/D;;AAEA;AACA,SAASC,SAASA,CAACC,KAAK,EAAEC,IAAI,EAAE;EAAA,IAAAC,OAAA,EAAAC,OAAA,EAAAC,gBAAA,EAAAC,qBAAA,EAAAC,cAAA,EAAAC,qBAAA;EAC9B,MAAMC,CAAC,GAAGR,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAES,MAAM;EACvB,MAAMC,CAAC,GAAGV,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEW,IAAI;EAErB,MAAMC,UAAU,GAAG,CAAAJ,CAAC,aAADA,CAAC,wBAAAN,OAAA,GAADM,CAAC,CAAEK,IAAI,cAAAX,OAAA,uBAAPA,OAAA,CAASY,OAAO,KAAI,IAAI;EAC3C,MAAMC,QAAQ,GAAG,CAAAL,CAAC,aAADA,CAAC,wBAAAP,OAAA,GAADO,CAAC,CAAEG,IAAI,cAAAV,OAAA,uBAAPA,OAAA,CAASW,OAAO,KAAI,IAAI;EAEzC,OAAO;IACLb,IAAI;IACJe,EAAE,EAAEnC,IAAI,CAACC,GAAG,CAAC,CAAC;IACd2B,MAAM,EAAED,CAAC,GACL;MACES,EAAE,EAAET,CAAC,CAACS,EAAE;MACRC,IAAI,GAAAd,gBAAA,GAAEQ,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEM,IAAI,cAAAd,gBAAA,cAAAA,gBAAA,GAAI,IAAI;MAC9Be,WAAW,GAAAd,qBAAA,GAAEO,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEO,WAAW,cAAAd,qBAAA,cAAAA,qBAAA,GAAI,IAAI;MAC5CQ,IAAI,EAAED;IACR,CAAC,GACD,IAAI;IACRD,IAAI,EAAED,CAAC,GACH;MACEO,EAAE,EAAEP,CAAC,CAACO,EAAE;MACRC,IAAI,GAAAZ,cAAA,GAAES,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEG,IAAI,cAAAZ,cAAA,cAAAA,cAAA,GAAI,IAAI;MAC5Ba,WAAW,GAAAZ,qBAAA,GAAEQ,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEI,WAAW,cAAAZ,qBAAA,cAAAA,qBAAA,GAAI,IAAI;MAC1CM,IAAI,EAAEE;IACR,CAAC,GACD;EACN,CAAC;AACH;AAEA,SAASK,kBAAkBA,CAACT,IAAI,EAAE;EAAA,IAAAU,UAAA,EAAAC,kBAAA;EAChC,IAAI,CAACX,IAAI,EAAE,OAAO,IAAI;;EAEtB;EACA,MAAMY,GAAG,IAAAF,UAAA,GAAGV,IAAI,CAACE,IAAI,cAAAQ,UAAA,wBAAAC,kBAAA,GAATD,UAAA,CAAWP,OAAO,cAAAQ,kBAAA,uBAAlBA,kBAAA,CAAoBH,WAAW;EAC3C,IAAII,GAAG,EAAE,OAAOA,GAAG;;EAEnB;EACA,IAAI,OAAOZ,IAAI,CAACM,EAAE,KAAK,QAAQ,EAAE;IAC/B,IAAIN,IAAI,CAACM,EAAE,CAACO,UAAU,CAAC,OAAO,CAAC,EAAE,OAAOb,IAAI,CAACM,EAAE,CAAC/B,KAAK,CAAC,OAAO,CAACuC,MAAM,CAAC;IACrE,IAAId,IAAI,CAACM,EAAE,CAACO,UAAU,CAAC,MAAM,CAAC,EAAE,OAAOb,IAAI,CAACM,EAAE,CAAC/B,KAAK,CAAC,MAAM,CAACuC,MAAM,CAAC;IACnE,IAAId,IAAI,CAACM,EAAE,CAACO,UAAU,CAAC,SAAS,CAAC,EAAE,OAAOb,IAAI,CAACM,EAAE,CAAC/B,KAAK,CAAC,SAAS,CAACuC,MAAM,CAAC;EAC3E;EAEA,OAAO,IAAI;AACb;AAEA,SAASC,yBAAyBA,CAACC,UAAU,EAAEC,IAAI,EAAE;EACnD,OAAOA,IAAI,CAACC,IAAI,CAAEhC,CAAC,IAAKA,CAAC,CAACC,KAAK,CAACgC,QAAQ,CAACH,UAAU,CAAC,CAAC;AACvD;;AAEA;AACA,OAAO,SAASI,wBAAwBA,CAAC;EAAEC,KAAK;EAAEC;AAAS,CAAC,EAAE;EAAAC,EAAA;EAC5D;EACA,MAAMC,kBAAkB,GAAG/D,MAAM,CAAC,IAAI,CAAC;;EAEvC;EACA,MAAMgE,WAAW,GAAGhE,MAAM,CAAC;IACzBiE,QAAQ,EAAE,IAAI;IACdC,MAAM,EAAE,IAAI;IACZC,QAAQ,EAAE,IAAI;IACdC,eAAe,EAAE;EACnB,CAAC,CAAC;EAEF,MAAMC,YAAY,GAAGvE,WAAW,CAAC,MAAM;IACrC,MAAM+C,EAAE,GAAGrC,GAAG,CAAC,CAAC;IAChBqD,QAAQ,CAAC5D,kBAAkB,CAAC;MAAE4C,EAAE;MAAEyB,KAAK,EAAE,QAAQV,KAAK,CAACrC,UAAU,CAAC8B,MAAM,GAAG,CAAC;IAAG,CAAC,CAAC,CAAC;EACpF,CAAC,EAAE,CAACQ,QAAQ,EAAED,KAAK,CAACrC,UAAU,CAAC8B,MAAM,CAAC,CAAC;EAEvC,MAAMkB,sBAAsB,GAAGzE,WAAW,CACvCiD,WAAW,IAAK;IACf,MAAMQ,UAAU,GAAG/C,GAAG,CAAC,CAAC;IACxBqD,QAAQ,CACN3D,4BAA4B,CAAC;MAC3B6C,WAAW;MACXyB,QAAQ,EAAE;QAAE3B,EAAE,EAAEU,UAAU;QAAEe,KAAK,EAAE,QAAQV,KAAK,CAACa,SAAS,CAACpB,MAAM,GAAG,CAAC;MAAG;IAC1E,CAAC,CACH,CAAC;EACH,CAAC,EACD,CAACQ,QAAQ,EAAED,KAAK,CAACa,SAAS,CAACpB,MAAM,CACnC,CAAC;EAED,MAAMqB,oBAAoB,GAAG5E,WAAW,CAAC,MAAM;IAAA,IAAA6E,qBAAA;IAC7C,QAAAA,qBAAA,GAAOZ,kBAAkB,CAACrB,OAAO,cAAAiC,qBAAA,cAAAA,qBAAA,GAAIf,KAAK,CAACrC,UAAU;EACvD,CAAC,EAAE,CAACqC,KAAK,CAACrC,UAAU,CAAC,CAAC;EAEtB,MAAMqD,eAAe,GAAG9E,WAAW,CAChC8B,KAAK,IAAK;IAAA,IAAAiD,kBAAA,EAAAC,qBAAA;IACTjB,QAAQ,CAACvD,mBAAmB,CAACqB,SAAS,CAACC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC;IACxDiC,QAAQ,CAAC1D,iBAAiB,CAACyB,KAAK,CAACS,MAAM,CAACQ,EAAE,CAAC,CAAC;IAE5C,MAAMkC,IAAI,IAAAF,kBAAA,GAAGjD,KAAK,CAACS,MAAM,CAAC0C,IAAI,cAAAF,kBAAA,wBAAAC,qBAAA,GAAjBD,kBAAA,CAAmBnC,OAAO,cAAAoC,qBAAA,uBAA1BA,qBAAA,CAA4BE,OAAO;IAChD,IAAID,IAAI,EAAElB,QAAQ,CAACzD,mBAAmB,CAAC;MAAE6E,KAAK,EAAEF,IAAI,CAACE,KAAK;MAAEC,MAAM,EAAEH,IAAI,CAACG;IAAO,CAAC,CAAC,CAAC;;IAEnF;IACAnB,kBAAkB,CAACrB,OAAO,GAAGpB,mBAAmB,CAACsC,KAAK,CAACrC,UAAU,CAAC;;IAElE;IACAyC,WAAW,CAACtB,OAAO,GAAG;MACpBuB,QAAQ,EAAErC,KAAK,CAACS,MAAM,CAACQ,EAAE;MACzBqB,MAAM,EAAE,IAAI;MACZC,QAAQ,EAAE,IAAI;MACdC,eAAe,EAAE;IACnB,CAAC;IAEDP,QAAQ,CAACtD,cAAc,CAAC,CAAC,CAAC;EAC5B,CAAC,EACD,CAACsD,QAAQ,EAAED,KAAK,CAACrC,UAAU,CAC7B,CAAC;EAED,MAAM4D,gBAAgB,GAAGrF,WAAW,CAAC,MAAM;IACzC+D,QAAQ,CAACvD,mBAAmB,CAAC;MAAEuB,IAAI,EAAE,QAAQ;MAAEe,EAAE,EAAEnC,IAAI,CAACC,GAAG,CAAC;IAAE,CAAC,CAAC,CAAC;IACjEmD,QAAQ,CAAC1D,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACjC0D,QAAQ,CAACzD,mBAAmB,CAAC,IAAI,CAAC,CAAC;IAEnC2D,kBAAkB,CAACrB,OAAO,GAAG,IAAI;IACjCmB,QAAQ,CAACtD,cAAc,CAAC,CAAC,CAAC;EAC5B,CAAC,EAAE,CAACsD,QAAQ,CAAC,CAAC;EAEd,MAAMuB,cAAc,GAAGtF,WAAW,CAC/B8B,KAAK,IAAK;IAAA,IAAAyD,qBAAA,EAAAC,mBAAA,EAAAC,qBAAA,EAAAC,mBAAA,EAAAC,oBAAA;IACTC,OAAO,CAACC,GAAG,CAAC,gBAAgB,CAAC;IAE7B,MAAM;MAAEtD,MAAM;MAAEE;IAAK,CAAC,GAAGX,KAAK;IAC9B,IAAI,CAACW,IAAI,EAAE;;IAEX;IACA,MAAMqD,YAAY,IAAAP,qBAAA,IAAAC,mBAAA,GAAG/C,IAAI,CAACE,IAAI,CAACC,OAAO,cAAA4C,mBAAA,uBAAjBA,mBAAA,CAAmBxC,IAAI,cAAAuC,qBAAA,cAAAA,qBAAA,GAAI,IAAI;IACpD,MAAMQ,mBAAmB,IAAAN,qBAAA,IAAAC,mBAAA,GACvBjD,IAAI,CAACE,IAAI,CAACC,OAAO,cAAA8C,mBAAA,uBAAjBA,mBAAA,CAAmBzC,WAAW,cAAAwC,qBAAA,cAAAA,qBAAA,GAAK,OAAOhD,IAAI,CAACM,EAAE,KAAK,QAAQ,GAAGN,IAAI,CAACM,EAAE,GAAG,IAAK;IAElF,MAAMiD,IAAI,GAAG9B,WAAW,CAACtB,OAAO;IAChC,MAAMqD,QAAQ,GACZD,IAAI,CAAC7B,QAAQ,KAAK5B,MAAM,CAACQ,EAAE,IAC3BiD,IAAI,CAAC5B,MAAM,KAAK3B,IAAI,CAACM,EAAE,IACvBiD,IAAI,CAAC3B,QAAQ,KAAKyB,YAAY,IAC9BE,IAAI,CAAC1B,eAAe,KAAKyB,mBAAmB;IAE9C,IAAI,CAACE,QAAQ,EAAE;MACb/B,WAAW,CAACtB,OAAO,GAAG;QACpBuB,QAAQ,EAAE5B,MAAM,CAACQ,EAAE;QACnBqB,MAAM,EAAE3B,IAAI,CAACM,EAAE;QACfsB,QAAQ,EAAEyB,YAAY;QACtBxB,eAAe,EAAEyB;MACnB,CAAC;MACDhC,QAAQ,CAACvD,mBAAmB,CAACqB,SAAS,CAACC,KAAK,EAAE,MAAM,CAAC,CAAC,CAAC;IACzD;IAEA,MAAMoE,KAAK,GAAGjC,kBAAkB,CAACrB,OAAO;IACxC,IAAI,CAACsD,KAAK,EAAE;IAEZ,MAAMC,UAAU,IAAAR,oBAAA,GAAGpD,MAAM,CAACI,IAAI,CAACC,OAAO,cAAA+C,oBAAA,uBAAnBA,oBAAA,CAAqB3C,IAAI;IAC5C,MAAMqB,QAAQ,GAAGyB,YAAY;;IAE7B;IACA,IAAIK,UAAU,KAAK,WAAW,EAAE;;IAEhC;IACA,IAAIA,UAAU,KAAK,UAAU,EAAE;IAE/B,MAAM1C,UAAU,GAAGlB,MAAM,CAACQ,EAAE;IAE5B,MAAMqD,aAAa,GAAG5C,yBAAyB,CAACC,UAAU,EAAEyC,KAAK,CAAC;IAClE,IAAI,CAACE,aAAa,EAAE;IAEpB,MAAMC,aAAa,GAAGnD,kBAAkB,CAACT,IAAI,CAAC;IAC9C,IAAI,CAAC4D,aAAa,EAAE;IAEpB,MAAMC,WAAW,GAAGJ,KAAK,CAACvC,IAAI,CAAEhC,CAAC,IAAKA,CAAC,CAACoB,EAAE,KAAKsD,aAAa,CAAC;IAC7D,IAAI,CAACC,WAAW,EAAE;IAElB,MAAMC,MAAM,GAAGH,aAAa,CAACrD,EAAE;IAC/B,MAAMyD,IAAI,GAAGF,WAAW,CAACvD,EAAE;IAE3B,MAAM0D,SAAS,GAAGL,aAAa,CAACxE,KAAK,CAAC8E,OAAO,CAACjD,UAAU,CAAC;IACzD,IAAIgD,SAAS,KAAK,CAAC,CAAC,EAAE;IAEtB,MAAME,cAAc,GAAGtC,QAAQ,KAAK,UAAU;IAC9C,MAAMuC,cAAc,GAAGD,cAAc,GAAGlE,IAAI,CAACM,EAAE,GAAG,IAAI;;IAEtD;IACA,IAAI8D,OAAO;IACX,IAAI,CAACD,cAAc,EAAE;MACnBC,OAAO,GAAGP,WAAW,CAAC1E,KAAK,CAAC2B,MAAM;IACpC,CAAC,MAAM;MACL,MAAMuD,GAAG,GAAGR,WAAW,CAAC1E,KAAK,CAAC8E,OAAO,CAACE,cAAc,CAAC;MACrDC,OAAO,GAAGC,GAAG,IAAI,CAAC,GAAGA,GAAG,GAAGR,WAAW,CAAC1E,KAAK,CAAC2B,MAAM;;MAEnD;MACA,MAAMwD,UAAU,GAAGxE,MAAM,CAAC0C,IAAI,CAACrC,OAAO,CAACoE,UAAU;MACjD,MAAMC,QAAQ,GAAGxE,IAAI,CAACwC,IAAI;MAE1B,MAAMiC,OAAO,GACXH,UAAU,IAAIE,QAAQ,GAClBF,UAAU,CAACI,GAAG,GAAGF,QAAQ,CAACE,GAAG,GAAGF,QAAQ,CAAC7B,MAAM,GAAG,CAAC,GACnD,KAAK;MAEXyB,OAAO,GAAGA,OAAO,IAAIK,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;IACvC;;IAEA;IACA;IACA;IACA,IAAIX,MAAM,KAAKC,IAAI,IAAI,CAACI,cAAc,EAAE;IACxC,IAAIA,cAAc,KAAKnD,UAAU,EAAE;;IAEnC;IACA;IACA;IACA,IAAI8C,MAAM,KAAKC,IAAI,EAAE;MACnB,IAAIK,OAAO,KAAKJ,SAAS,EAAE;MAE3B,MAAMW,SAAS,GAAGnG,SAAS,CAACmF,aAAa,CAACxE,KAAK,EAAE6E,SAAS,EAAEI,OAAO,CAAC;MAEpE5C,kBAAkB,CAACrB,OAAO,GAAGsD,KAAK,CAACxE,GAAG,CAAEC,CAAC,IACvCA,CAAC,CAACoB,EAAE,KAAKwD,MAAM,GAAG;QAAE,GAAG5E,CAAC;QAAEC,KAAK,EAAEwF;MAAU,CAAC,GAAGzF,CACjD,CAAC;MAEDoC,QAAQ,CAACtD,cAAc,CAAC,CAAC,CAAC;MAC1BmF,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC;MAC3B;IACF;;IAEA;IACA;IACA;IACA,MAAMwB,aAAa,GAAGjB,aAAa,CAACxE,KAAK,CAAC0F,MAAM,CAAEvE,EAAE,IAAKA,EAAE,KAAKU,UAAU,CAAC;IAE3E,MAAM8D,OAAO,GAAGzG,IAAI,CAAC0G,GAAG,CAAC,CAAC,EAAE1G,IAAI,CAAC2G,GAAG,CAACnB,WAAW,CAAC1E,KAAK,CAAC2B,MAAM,EAAEsD,OAAO,CAAC,CAAC;IACxE,MAAMa,WAAW,GAAG,CAAC,GAAGpB,WAAW,CAAC1E,KAAK,CAAC;IAC1C8F,WAAW,CAACnG,MAAM,CAACgG,OAAO,EAAE,CAAC,EAAE9D,UAAU,CAAC;IAE1CQ,kBAAkB,CAACrB,OAAO,GAAGsD,KAAK,CAACxE,GAAG,CAAEC,CAAC,IAAK;MAC5C,IAAIA,CAAC,CAACoB,EAAE,KAAKwD,MAAM,EAAE,OAAO;QAAE,GAAG5E,CAAC;QAAEC,KAAK,EAAEyF;MAAc,CAAC;MAC1D,IAAI1F,CAAC,CAACoB,EAAE,KAAKyD,IAAI,EAAE,OAAO;QAAE,GAAG7E,CAAC;QAAEC,KAAK,EAAE8F;MAAY,CAAC;MACtD,OAAO/F,CAAC;IACV,CAAC,CAAC;IAEFoC,QAAQ,CAACtD,cAAc,CAAC,CAAC,CAAC;IAC1BmF,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC;EAC7B,CAAC,EACD,CAAC9B,QAAQ,CACX,CAAC;EAED,MAAM4D,aAAa,GAAG3H,WAAW,CAC9B8B,KAAK,IAAK;IACTiC,QAAQ,CAACvD,mBAAmB,CAACqB,SAAS,CAACC,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC;IAEtD,MAAM;MAAEW;IAAK,CAAC,GAAGX,KAAK;IAEtBiC,QAAQ,CAAC1D,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACjC0D,QAAQ,CAACzD,mBAAmB,CAAC,IAAI,CAAC,CAAC;;IAEnC;IACA,IAAI,CAACmC,IAAI,EAAE;MACTwB,kBAAkB,CAACrB,OAAO,GAAG,IAAI;MACjCmB,QAAQ,CAACtD,cAAc,CAAC,CAAC,CAAC;MAC1B;IACF;;IAEA;IACA,IAAIwD,kBAAkB,CAACrB,OAAO,EAAE;MAC9BmB,QAAQ,CAACxD,mBAAmB,CAAC0D,kBAAkB,CAACrB,OAAO,CAAC,CAAC;MACzDqB,kBAAkB,CAACrB,OAAO,GAAG,IAAI;MACjCmB,QAAQ,CAACtD,cAAc,CAAC,CAAC,CAAC;IAC5B;EACF,CAAC,EACD,CAACsD,QAAQ,CACX,CAAC;EAED,OAAO9D,OAAO,CACZ,OAAO;IACL;IACAsE,YAAY;IACZE,sBAAsB;IAEtB;IACAK,eAAe;IACfQ,cAAc;IACdqC,aAAa;IACbtC,gBAAgB;IAEhB;IACApB,kBAAkB;IAClBW;EACF,CAAC,CAAC,EACF,CACEL,YAAY,EACZE,sBAAsB,EACtBK,eAAe,EACfQ,cAAc,EACdqC,aAAa,EACbtC,gBAAgB,EAChBT,oBAAoB,CAExB,CAAC;AACH;AAACZ,EAAA,CApPeH,wBAAwB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}